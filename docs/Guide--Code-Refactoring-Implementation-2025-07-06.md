# ì½”ë“œ ë¦¬íŒ©í„°ë§ êµ¬í˜„ ê°€ì´ë“œ
*ì‘ì„±ì¼: 2025-07-06*
*ê¸°ë°˜: ì‹¤ì œ ì½”ë“œ ë¶„ì„ ê²°ê³¼*

## ğŸ“‹ ê°œìš”

ì´ ë¬¸ì„œëŠ” Xai Community í”„ë¡œì íŠ¸ì˜ ì‹¤ì œ ì½”ë“œ ë¶„ì„ ê²°ê³¼ë¥¼ ë°”íƒ•ìœ¼ë¡œ êµ¬ì²´ì ì¸ ë¦¬íŒ©í„°ë§ êµ¬í˜„ ë°©ë²•ì„ ì œì‹œí•©ë‹ˆë‹¤. ë°±ì—”ë“œì™€ í”„ëŸ°íŠ¸ì—”ë“œ ì½”ë“œë² ì´ìŠ¤ì—ì„œ ë°œê²¬ëœ ì‹¤ì œ ë¬¸ì œì ë“¤ì„ í•´ê²°í•˜ëŠ” êµ¬ì²´ì ì¸ ì½”ë“œ ì˜ˆì‹œì™€ ë‹¨ê³„ë³„ êµ¬í˜„ ê°€ì´ë“œë¥¼ í¬í•¨í•©ë‹ˆë‹¤.

## ğŸ” ì‹¤ì œ ë¶„ì„ ê²°ê³¼ ìš”ì•½

### ë°±ì—”ë“œ í˜„í™© (í‰ê°€: 8/10)
**ê°•ì :**
- âœ… ëª…í™•í•œ DDD ê³„ì¸µ êµ¬ì¡° (API â†’ Service â†’ Repository â†’ Model)
- âœ… í¬ê´„ì ì¸ í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ (57ê°œ í…ŒìŠ¤íŠ¸ íŒŒì¼)
- âœ… ê°•ë ¥í•œ íƒ€ì… íŒíŒ… ë° ë°ì´í„° ê²€ì¦ (Pydantic + Beanie)
- âœ… ë¹„ë™ê¸° ì²˜ë¦¬ ë° MongoDB ìµœì í™”

**ë¬¸ì œì :**
- ğŸš¨ ëŒ€í˜• íŒŒì¼ë“¤: `models/core.py` (495ì¤„), `services/posts_service.py` (688ì¤„), `config.py` (546ì¤„)
- ğŸš¨ ë¡œê¹… ì‹œìŠ¤í…œ ë¶€ì¡±: `print()` ë¬¸ ì‚¬ìš©, êµ¬ì¡°í™”ëœ ë¡œê¹… ë¶€ì¬
- âš ï¸ ìˆœí™˜ ì°¸ì¡° ìœ„í—˜: ì„œë¹„ìŠ¤ ê°„ import êµ¬ì¡°
- âš ï¸ ì—ëŸ¬ ì²˜ë¦¬ ë¶ˆì¼ì¹˜: í•˜ë“œì½”ë”©ëœ ì—ëŸ¬ ë©”ì‹œì§€

### í”„ëŸ°íŠ¸ì—”ë“œ í˜„í™© (í‰ê°€: 7/10)
**ê°•ì :**
- âœ… Remix ê¸°ë°˜ ê²¬ê³ í•œ ì•„í‚¤í…ì²˜
- âœ… ì²´ê³„ì ì¸ í…ŒìŠ¤íŠ¸ êµ¬ì¡° (ë‹¨ìœ„/í†µí•©/E2E)
- âœ… ì»´í¬ë„ŒíŠ¸ ì¬ì‚¬ìš©ì„± ë†’ìŒ
- âœ… í† í° ìë™ ê°±ì‹  ì‹œìŠ¤í…œ

**ë¬¸ì œì :**
- ğŸš¨ íƒ€ì… ì‹œìŠ¤í…œ ë³µì¡ì„±: ë°±ì—”ë“œ í˜¸í™˜ì„±ìœ¼ë¡œ ì¸í•œ ì¤‘ë³µ í•„ë“œ
- ğŸš¨ Context ì¤‘ì²© ë¬¸ì œ: ì„±ëŠ¥ ì €í•˜ ë° ë³µì¡ì„± ì¦ê°€
- ğŸš¨ API í´ë¼ì´ì–¸íŠ¸ ê³¼ë¶€í•˜: 900+ ë¼ì¸ ë‹¨ì¼ í´ë˜ìŠ¤
- âš ï¸ ì ‘ê·¼ì„± ë¶€ì¡±: ARIA ì†ì„±, í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´ì…˜ ë¯¸í¡

## ğŸ› ï¸ êµ¬ì²´ì ì¸ ë¦¬íŒ©í„°ë§ êµ¬í˜„ ê°€ì´ë“œ

### ğŸ”¥ 1ë‹¨ê³„: ê¸´ê¸‰ ê°œì„  (1-2ì£¼)

#### ë°±ì—”ë“œ - ê¸´ê¸‰ ê°œì„ 

##### 1.1 ë¡œê¹… ì‹œìŠ¤í…œ í‘œì¤€í™”

**í˜„ì¬ ë¬¸ì œì :**
```python
# í˜„ì¬: print ë¬¸ ì‚¬ìš©
print(f"Post created: {post.slug}")
print(f"Error: {str(e)}")

# í˜„ì¬: ë¡œê¹… ì—†ìŒ
try:
    result = await collection.find_one({"_id": post_id})
except Exception as e:
    print(f"Database error: {e}")  # ë¹„êµ¬ì¡°í™”ëœ ë¡œê¹…
```

**ê°œì„  êµ¬í˜„:**
```python
# 1. ë¡œê¹… ì„¤ì • íŒŒì¼ ìƒì„±
# backend/nadle_backend/logging_config.py
import logging
import logging.config
from typing import Dict, Any

LOGGING_CONFIG: Dict[str, Any] = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'standard': {
            'format': '%(asctime)s [%(levelname)s] %(name)s: %(message)s'
        },
        'detailed': {
            'format': '%(asctime)s [%(levelname)s] %(name)s:%(lineno)d: %(message)s'
        },
        'json': {
            'format': '{"timestamp": "%(asctime)s", "level": "%(levelname)s", "logger": "%(name)s", "message": "%(message)s"}'
        }
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'level': 'INFO',
            'formatter': 'standard',
            'stream': 'ext://sys.stdout'
        },
        'file': {
            'class': 'logging.FileHandler',
            'level': 'DEBUG',
            'formatter': 'detailed',
            'filename': 'logs/app.log',
            'mode': 'a',
        },
        'error_file': {
            'class': 'logging.FileHandler',
            'level': 'ERROR',
            'formatter': 'json',
            'filename': 'logs/errors.log',
            'mode': 'a',
        }
    },
    'loggers': {
        '': {  # root logger
            'handlers': ['console', 'file'],
            'level': 'INFO',
            'propagate': False
        },
        'nadle_backend': {
            'handlers': ['console', 'file', 'error_file'],
            'level': 'DEBUG',
            'propagate': False
        }
    }
}

def setup_logging():
    """ë¡œê¹… ì„¤ì • ì´ˆê¸°í™”"""
    logging.config.dictConfig(LOGGING_CONFIG)
    logger = logging.getLogger(__name__)
    logger.info("ë¡œê¹… ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ")

# 2. ê° ëª¨ë“ˆì—ì„œ ë¡œê±° ì‚¬ìš©
# backend/nadle_backend/repositories/post_repository.py
import logging
from typing import Optional, List
from nadle_backend.models.core import Post

logger = logging.getLogger(__name__)

class PostRepository:
    async def create_post(self, post_data: dict) -> Post:
        """ê²Œì‹œê¸€ ìƒì„±"""
        try:
            logger.info(f"ê²Œì‹œê¸€ ìƒì„± ì‹œì‘: {post_data.get('title', 'Unknown')}")
            
            post = Post(**post_data)
            await post.save()
            
            logger.info(f"ê²Œì‹œê¸€ ìƒì„± ì™„ë£Œ: {post.slug}")
            return post
            
        except Exception as e:
            logger.error(f"ê²Œì‹œê¸€ ìƒì„± ì‹¤íŒ¨: {str(e)}", exc_info=True)
            raise

    async def get_post_by_slug(self, slug: str) -> Optional[Post]:
        """ìŠ¬ëŸ¬ê·¸ë¡œ ê²Œì‹œê¸€ ì¡°íšŒ"""
        try:
            logger.debug(f"ê²Œì‹œê¸€ ì¡°íšŒ ì‹œì‘: {slug}")
            
            post = await Post.find_one({"slug": slug})
            
            if post:
                logger.debug(f"ê²Œì‹œê¸€ ì¡°íšŒ ì„±ê³µ: {slug}")
            else:
                logger.warning(f"ê²Œì‹œê¸€ ì¡°íšŒ ì‹¤íŒ¨ - ì¡´ì¬í•˜ì§€ ì•ŠìŒ: {slug}")
            
            return post
            
        except Exception as e:
            logger.error(f"ê²Œì‹œê¸€ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {slug}, {str(e)}", exc_info=True)
            raise
```

##### 1.2 ëŒ€í˜• íŒŒì¼ ë¶„ë¦¬ - models/core.py

**í˜„ì¬ ë¬¸ì œì :**
```python
# models/core.py (495ì¤„) - ëª¨ë“  ëª¨ë¸ì´ í•œ íŒŒì¼ì— ìˆìŒ
class User(Document):
    # ì‚¬ìš©ì ê´€ë ¨ í•„ë“œë“¤...

class Post(Document):
    # ê²Œì‹œê¸€ ê´€ë ¨ í•„ë“œë“¤...

class Comment(Document):
    # ëŒ“ê¸€ ê´€ë ¨ í•„ë“œë“¤...
```

**ê°œì„  êµ¬í˜„:**
```python
# 1. ëª¨ë¸ ë¶„ë¦¬
# backend/nadle_backend/models/__init__.py
from .user import User, UserCreate, UserUpdate
from .post import Post, PostCreate, PostUpdate, PostDetail
from .comment import Comment, CommentCreate, CommentUpdate, CommentDetail
from .file import FileUpload, FileMetadata
from .common import BaseDocument, PaginationResponse

__all__ = [
    "User", "UserCreate", "UserUpdate",
    "Post", "PostCreate", "PostUpdate", "PostDetail",
    "Comment", "CommentCreate", "CommentUpdate", "CommentDetail",
    "FileUpload", "FileMetadata",
    "BaseDocument", "PaginationResponse"
]

# 2. ê¸°ë³¸ ëª¨ë¸ í´ë˜ìŠ¤
# backend/nadle_backend/models/common.py
from beanie import Document
from pydantic import BaseModel, Field
from typing import Optional, List, TypeVar, Generic
from datetime import datetime
from bson import ObjectId

T = TypeVar('T')

class BaseDocument(Document):
    """ëª¨ë“  ë¬¸ì„œ ëª¨ë¸ì˜ ê¸°ë³¸ í´ë˜ìŠ¤"""
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    
    class Settings:
        # ê³µí†µ ì„¤ì •
        use_enum_values = True
        validate_assignment = True

class PaginationResponse(BaseModel, Generic[T]):
    """í˜ì´ì§€ë„¤ì´ì…˜ ì‘ë‹µ ëª¨ë¸"""
    items: List[T]
    total: int
    page: int
    size: int
    total_pages: int
    has_next: bool
    has_prev: bool

# 3. ì‚¬ìš©ì ëª¨ë¸ ë¶„ë¦¬
# backend/nadle_backend/models/user.py
from beanie import Document
from pydantic import BaseModel, Field, EmailStr
from typing import Optional, List
from datetime import datetime
from .common import BaseDocument

class User(BaseDocument):
    """ì‚¬ìš©ì ëª¨ë¸"""
    username: str = Field(..., min_length=3, max_length=50)
    email: EmailStr = Field(..., unique=True)
    password_hash: str = Field(..., alias="password")
    display_name: Optional[str] = Field(None, max_length=100)
    bio: Optional[str] = Field(None, max_length=500)
    avatar_url: Optional[str] = None
    is_active: bool = Field(default=True)
    is_verified: bool = Field(default=False)
    last_login: Optional[datetime] = None
    
    class Settings:
        collection = "users"
        indexes = [
            "username",
            "email",
            "created_at",
        ]

class UserCreate(BaseModel):
    """ì‚¬ìš©ì ìƒì„± ìš”ì²­ ëª¨ë¸"""
    username: str = Field(..., min_length=3, max_length=50)
    email: EmailStr
    password: str = Field(..., min_length=8)
    display_name: Optional[str] = Field(None, max_length=100)

class UserUpdate(BaseModel):
    """ì‚¬ìš©ì ì—…ë°ì´íŠ¸ ìš”ì²­ ëª¨ë¸"""
    display_name: Optional[str] = Field(None, max_length=100)
    bio: Optional[str] = Field(None, max_length=500)
    avatar_url: Optional[str] = None

class UserResponse(BaseModel):
    """ì‚¬ìš©ì ì‘ë‹µ ëª¨ë¸"""
    id: str
    username: str
    email: str
    display_name: Optional[str]
    bio: Optional[str]
    avatar_url: Optional[str]
    is_active: bool
    is_verified: bool
    created_at: datetime
    
    @classmethod
    def from_user(cls, user: User) -> "UserResponse":
        """User ëª¨ë¸ì—ì„œ ì‘ë‹µ ëª¨ë¸ë¡œ ë³€í™˜"""
        return cls(
            id=str(user.id),
            username=user.username,
            email=user.email,
            display_name=user.display_name,
            bio=user.bio,
            avatar_url=user.avatar_url,
            is_active=user.is_active,
            is_verified=user.is_verified,
            created_at=user.created_at
        )

# 4. ê²Œì‹œê¸€ ëª¨ë¸ ë¶„ë¦¬
# backend/nadle_backend/models/post.py
from beanie import Document
from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any
from datetime import datetime
from enum import Enum
from .common import BaseDocument

class PostStatus(str, Enum):
    DRAFT = "draft"
    PUBLISHED = "published"
    ARCHIVED = "archived"

class PostType(str, Enum):
    GENERAL = "general"
    QUESTION = "question"
    ANNOUNCEMENT = "announcement"
    TUTORIAL = "tutorial"

class Post(BaseDocument):
    """ê²Œì‹œê¸€ ëª¨ë¸"""
    title: str = Field(..., min_length=1, max_length=200)
    slug: str = Field(..., unique=True, max_length=200)
    content: str = Field(..., min_length=1)
    summary: Optional[str] = Field(None, max_length=300)
    
    # ì‘ì„±ì ì •ë³´
    author_id: str = Field(..., alias="user_id")
    author_name: str = Field(..., max_length=100)
    
    # ê²Œì‹œê¸€ ë©”íƒ€ë°ì´í„°
    post_type: PostType = Field(default=PostType.GENERAL)
    status: PostStatus = Field(default=PostStatus.PUBLISHED)
    metadata_type: Optional[str] = Field(None, max_length=100)
    
    # íƒœê·¸ ë° ì¹´í…Œê³ ë¦¬
    tags: List[str] = Field(default_factory=list)
    category: Optional[str] = Field(None, max_length=50)
    
    # í†µê³„
    view_count: int = Field(default=0)
    like_count: int = Field(default=0)
    comment_count: int = Field(default=0)
    
    # ì²¨ë¶€íŒŒì¼
    attachments: List[str] = Field(default_factory=list)
    
    # ë°œí–‰ ì •ë³´
    published_at: Optional[datetime] = None
    
    class Settings:
        collection = "posts"
        indexes = [
            "slug",
            "author_id",
            "post_type",
            "status",
            "metadata_type",
            "published_at",
            "created_at",
            [("title", "text"), ("content", "text")],  # í…ìŠ¤íŠ¸ ê²€ìƒ‰ ì¸ë±ìŠ¤
        ]

class PostCreate(BaseModel):
    """ê²Œì‹œê¸€ ìƒì„± ìš”ì²­ ëª¨ë¸"""
    title: str = Field(..., min_length=1, max_length=200)
    content: str = Field(..., min_length=1)
    summary: Optional[str] = Field(None, max_length=300)
    post_type: PostType = Field(default=PostType.GENERAL)
    metadata_type: Optional[str] = Field(None, max_length=100)
    tags: List[str] = Field(default_factory=list)
    category: Optional[str] = Field(None, max_length=50)
    attachments: List[str] = Field(default_factory=list)
    status: PostStatus = Field(default=PostStatus.PUBLISHED)

class PostUpdate(BaseModel):
    """ê²Œì‹œê¸€ ì—…ë°ì´íŠ¸ ìš”ì²­ ëª¨ë¸"""
    title: Optional[str] = Field(None, min_length=1, max_length=200)
    content: Optional[str] = Field(None, min_length=1)
    summary: Optional[str] = Field(None, max_length=300)
    post_type: Optional[PostType] = None
    metadata_type: Optional[str] = Field(None, max_length=100)
    tags: Optional[List[str]] = None
    category: Optional[str] = Field(None, max_length=50)
    attachments: Optional[List[str]] = None
    status: Optional[PostStatus] = None

class PostResponse(BaseModel):
    """ê²Œì‹œê¸€ ì‘ë‹µ ëª¨ë¸"""
    id: str
    title: str
    slug: str
    content: str
    summary: Optional[str]
    author_id: str
    author_name: str
    post_type: PostType
    status: PostStatus
    metadata_type: Optional[str]
    tags: List[str]
    category: Optional[str]
    view_count: int
    like_count: int
    comment_count: int
    attachments: List[str]
    created_at: datetime
    updated_at: datetime
    published_at: Optional[datetime]
    
    @classmethod
    def from_post(cls, post: Post) -> "PostResponse":
        """Post ëª¨ë¸ì—ì„œ ì‘ë‹µ ëª¨ë¸ë¡œ ë³€í™˜"""
        return cls(
            id=str(post.id),
            title=post.title,
            slug=post.slug,
            content=post.content,
            summary=post.summary,
            author_id=post.author_id,
            author_name=post.author_name,
            post_type=post.post_type,
            status=post.status,
            metadata_type=post.metadata_type,
            tags=post.tags,
            category=post.category,
            view_count=post.view_count,
            like_count=post.like_count,
            comment_count=post.comment_count,
            attachments=post.attachments,
            created_at=post.created_at,
            updated_at=post.updated_at,
            published_at=post.published_at
        )
```

##### 1.3 ìˆœí™˜ ì°¸ì¡° í•´ê²°

**í˜„ì¬ ë¬¸ì œì :**
```python
# services/posts_service.py
from nadle_backend.services.user_activity_service import normalize_post_type
# ì´ëŸ° ì„œë¹„ìŠ¤ ê°„ importëŠ” ìˆœí™˜ ì°¸ì¡° ìœ„í—˜
```

**ê°œì„  êµ¬í˜„:**
```python
# 1. ê³µí†µ ìœ í‹¸ë¦¬í‹° ëª¨ë“ˆ ìƒì„±
# backend/nadle_backend/utils/post_utils.py
from typing import Optional, Dict, Any
from enum import Enum

class PostTypeMapping(str, Enum):
    """ê²Œì‹œê¸€ íƒ€ì… ë§¤í•‘"""
    GENERAL = "general"
    QUESTION = "question"
    ANNOUNCEMENT = "announcement"
    TUTORIAL = "tutorial"
    SERVICE = "service"
    MOVING_SERVICE = "moving_service"

def normalize_post_type(post_type: str) -> str:
    """ê²Œì‹œê¸€ íƒ€ì… ì •ê·œí™”"""
    type_mapping = {
        "moving services": PostTypeMapping.MOVING_SERVICE,
        "general": PostTypeMapping.GENERAL,
        "question": PostTypeMapping.QUESTION,
        "announcement": PostTypeMapping.ANNOUNCEMENT,
        "tutorial": PostTypeMapping.TUTORIAL,
    }
    return type_mapping.get(post_type.lower(), PostTypeMapping.GENERAL)

def get_post_metadata(post_type: str) -> Dict[str, Any]:
    """ê²Œì‹œê¸€ ë©”íƒ€ë°ì´í„° ìƒì„±"""
    metadata = {
        "type": normalize_post_type(post_type),
        "searchable": True,
        "indexable": True,
    }
    
    if post_type in ["moving services", "service"]:
        metadata.update({
            "requires_approval": True,
            "featured": False,
            "priority": 1
        })
    
    return metadata

# 2. ì„œë¹„ìŠ¤ì—ì„œ ìœ í‹¸ë¦¬í‹° ì‚¬ìš©
# backend/nadle_backend/services/posts_service.py
import logging
from typing import Optional, List, Dict, Any
from nadle_backend.models.post import Post, PostCreate, PostUpdate, PostResponse
from nadle_backend.repositories.post_repository import PostRepository
from nadle_backend.utils.post_utils import normalize_post_type, get_post_metadata
from nadle_backend.exceptions.post import PostNotFoundError, PostCreateError

logger = logging.getLogger(__name__)

class PostsService:
    def __init__(self, post_repository: PostRepository):
        self.post_repository = post_repository

    async def create_post(self, post_data: PostCreate, user_id: str) -> PostResponse:
        """ê²Œì‹œê¸€ ìƒì„±"""
        try:
            logger.info(f"ê²Œì‹œê¸€ ìƒì„± ì‹œì‘: {post_data.title}")
            
            # ê²Œì‹œê¸€ ë°ì´í„° ì¤€ë¹„
            post_dict = post_data.dict()
            post_dict["author_id"] = user_id
            
            # ë©”íƒ€ë°ì´í„° ì„¤ì •
            if post_data.metadata_type:
                post_dict["metadata_type"] = normalize_post_type(post_data.metadata_type)
            
            # ìŠ¬ëŸ¬ê·¸ ìƒì„±
            post_dict["slug"] = await self._generate_unique_slug(post_data.title)
            
            # ê²Œì‹œê¸€ ìƒì„±
            post = await self.post_repository.create_post(post_dict)
            
            logger.info(f"ê²Œì‹œê¸€ ìƒì„± ì™„ë£Œ: {post.slug}")
            return PostResponse.from_post(post)
            
        except Exception as e:
            logger.error(f"ê²Œì‹œê¸€ ìƒì„± ì‹¤íŒ¨: {str(e)}")
            raise PostCreateError(f"ê²Œì‹œê¸€ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {str(e)}")

    async def _generate_unique_slug(self, title: str) -> str:
        """ê³ ìœ í•œ ìŠ¬ëŸ¬ê·¸ ìƒì„±"""
        base_slug = self._create_slug_from_title(title)
        slug = base_slug
        counter = 1
        
        while await self.post_repository.get_post_by_slug(slug):
            slug = f"{base_slug}-{counter}"
            counter += 1
            
        return slug

    def _create_slug_from_title(self, title: str) -> str:
        """ì œëª©ì—ì„œ ìŠ¬ëŸ¬ê·¸ ìƒì„±"""
        import re
        slug = re.sub(r'[^\w\s-]', '', title.lower())
        slug = re.sub(r'[-\s]+', '-', slug)
        return slug.strip('-')
```

##### 1.4 ì „ì—­ ì—ëŸ¬ ì²˜ë¦¬ í‘œì¤€í™”

**í˜„ì¬ ë¬¸ì œì :**
```python
# ê° ì„œë¹„ìŠ¤ë§ˆë‹¤ ë‹¤ë¥¸ ì—ëŸ¬ ì²˜ë¦¬ ë°©ì‹
# í•˜ë“œì½”ë”©ëœ ì—ëŸ¬ ë©”ì‹œì§€
# ì¼ê´€ì„± ì—†ëŠ” HTTP ìƒíƒœ ì½”ë“œ
```

**ê°œì„  êµ¬í˜„:**
```python
# 1. ì—ëŸ¬ ì‘ë‹µ í‘œì¤€í™”
# backend/nadle_backend/exceptions/handlers.py
from fastapi import HTTPException, Request
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException as StarletteHTTPException
import logging
from typing import Dict, Any

logger = logging.getLogger(__name__)

class ErrorResponse:
    """í‘œì¤€í™”ëœ ì—ëŸ¬ ì‘ë‹µ"""
    def __init__(self, code: str, message: str, details: Dict[str, Any] = None):
        self.code = code
        self.message = message
        self.details = details or {}

    def to_dict(self) -> Dict[str, Any]:
        return {
            "error": {
                "code": self.code,
                "message": self.message,
                "details": self.details
            }
        }

async def http_exception_handler(request: Request, exc: StarletteHTTPException) -> JSONResponse:
    """HTTP ì˜ˆì™¸ ì²˜ë¦¬ê¸°"""
    logger.error(f"HTTP ì˜ˆì™¸ ë°œìƒ: {exc.status_code} - {exc.detail}")
    
    error_response = ErrorResponse(
        code=f"HTTP_{exc.status_code}",
        message=exc.detail,
        details={"status_code": exc.status_code}
    )
    
    return JSONResponse(
        status_code=exc.status_code,
        content=error_response.to_dict()
    )

async def validation_exception_handler(request: Request, exc: RequestValidationError) -> JSONResponse:
    """ì…ë ¥ ê²€ì¦ ì˜ˆì™¸ ì²˜ë¦¬ê¸°"""
    logger.error(f"ì…ë ¥ ê²€ì¦ ì˜¤ë¥˜: {exc.errors()}")
    
    error_response = ErrorResponse(
        code="VALIDATION_ERROR",
        message="ì…ë ¥ ë°ì´í„°ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.",
        details={"errors": exc.errors()}
    )
    
    return JSONResponse(
        status_code=422,
        content=error_response.to_dict()
    )

async def general_exception_handler(request: Request, exc: Exception) -> JSONResponse:
    """ì¼ë°˜ ì˜ˆì™¸ ì²˜ë¦¬ê¸°"""
    logger.error(f"ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ ë°œìƒ: {str(exc)}", exc_info=True)
    
    error_response = ErrorResponse(
        code="INTERNAL_ERROR",
        message="ì„œë²„ ë‚´ë¶€ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
        details={"type": type(exc).__name__}
    )
    
    return JSONResponse(
        status_code=500,
        content=error_response.to_dict()
    )

# 2. ì»¤ìŠ¤í…€ ì˜ˆì™¸ í´ë˜ìŠ¤ í™•ì¥
# backend/nadle_backend/exceptions/base.py
from typing import Optional, Dict, Any

class BaseAppException(Exception):
    """ì• í”Œë¦¬ì¼€ì´ì…˜ ê¸°ë³¸ ì˜ˆì™¸"""
    def __init__(
        self,
        message: str,
        code: str = "APP_ERROR",
        details: Optional[Dict[str, Any]] = None,
        status_code: int = 500
    ):
        self.message = message
        self.code = code
        self.details = details or {}
        self.status_code = status_code
        super().__init__(self.message)

    def to_error_response(self) -> ErrorResponse:
        """ì—ëŸ¬ ì‘ë‹µ ê°ì²´ë¡œ ë³€í™˜"""
        return ErrorResponse(
            code=self.code,
            message=self.message,
            details=self.details
        )

class BusinessLogicError(BaseAppException):
    """ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì˜¤ë¥˜"""
    def __init__(self, message: str, details: Optional[Dict[str, Any]] = None):
        super().__init__(
            message=message,
            code="BUSINESS_ERROR",
            details=details,
            status_code=400
        )

class ResourceNotFoundError(BaseAppException):
    """ë¦¬ì†ŒìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ"""
    def __init__(self, resource_type: str, resource_id: str):
        super().__init__(
            message=f"{resource_type}ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
            code="RESOURCE_NOT_FOUND",
            details={"resource_type": resource_type, "resource_id": resource_id},
            status_code=404
        )

class AuthenticationError(BaseAppException):
    """ì¸ì¦ ì˜¤ë¥˜"""
    def __init__(self, message: str = "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤."):
        super().__init__(
            message=message,
            code="AUTHENTICATION_ERROR",
            status_code=401
        )

class AuthorizationError(BaseAppException):
    """ê¶Œí•œ ì˜¤ë¥˜"""
    def __init__(self, message: str = "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤."):
        super().__init__(
            message=message,
            code="AUTHORIZATION_ERROR",
            status_code=403
        )

# 3. FastAPI ì•±ì— ì˜ˆì™¸ ì²˜ë¦¬ê¸° ë“±ë¡
# backend/main.py
from fastapi import FastAPI
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException as StarletteHTTPException
from nadle_backend.exceptions.handlers import (
    http_exception_handler,
    validation_exception_handler,
    general_exception_handler
)
from nadle_backend.exceptions.base import BaseAppException

app = FastAPI(title="Nadle Backend API")

# ì˜ˆì™¸ ì²˜ë¦¬ê¸° ë“±ë¡
app.add_exception_handler(StarletteHTTPException, http_exception_handler)
app.add_exception_handler(RequestValidationError, validation_exception_handler)
app.add_exception_handler(BaseAppException, general_exception_handler)
app.add_exception_handler(Exception, general_exception_handler)
```

#### í”„ëŸ°íŠ¸ì—”ë“œ - ê¸´ê¸‰ ê°œì„ 

##### 1.5 íƒ€ì… ì‹œìŠ¤í…œ ë‹¨ìˆœí™”

**í˜„ì¬ ë¬¸ì œì :**
```typescript
// ë³µì¡í•œ íƒ€ì… ì¤‘ë³µ ë° ë°±ì—”ë“œ í˜¸í™˜ì„± ë¬¸ì œ
export interface Service extends ServicePost, BaseListItem {
  author?: any;
  author_id?: string;
  user_id?: string;
  created_by?: string;
  
  stats?: ItemStats;
  serviceStats?: ServiceStats;
  likes?: number;
  dislikes?: number;
  bookmarks?: number;
}
```

**ê°œì„  êµ¬í˜„:**
```typescript
// 1. ë„ë©”ì¸ë³„ íƒ€ì… ë¶„ë¦¬
// frontend/app/types/common.ts
export interface BaseEntity {
  id: string;
  created_at: string;
  updated_at: string;
}

export interface Author {
  id: string;
  name: string;
  email?: string;
  avatar_url?: string;
}

export interface Stats {
  views: number;
  likes: number;
  dislikes: number;
  comments: number;
  bookmarks: number;
}

export interface PaginationParams {
  page: number;
  size: number;
}

export interface PaginationResponse<T> {
  items: T[];
  total: number;
  page: number;
  size: number;
  total_pages: number;
  has_next: boolean;
  has_prev: boolean;
}

// 2. ê²Œì‹œê¸€ íƒ€ì… ì •ì˜
// frontend/app/types/post.ts
import { BaseEntity, Author, Stats } from './common';

export enum PostType {
  GENERAL = 'general',
  QUESTION = 'question',
  ANNOUNCEMENT = 'announcement',
  TUTORIAL = 'tutorial',
  SERVICE = 'service',
  MOVING_SERVICE = 'moving_service'
}

export enum PostStatus {
  DRAFT = 'draft',
  PUBLISHED = 'published',
  ARCHIVED = 'archived'
}

export interface Post extends BaseEntity {
  title: string;
  slug: string;
  content: string;
  summary?: string;
  author: Author;
  post_type: PostType;
  status: PostStatus;
  metadata_type?: string;
  tags: string[];
  category?: string;
  stats: Stats;
  attachments: string[];
  published_at?: string;
}

export interface PostCreate {
  title: string;
  content: string;
  summary?: string;
  post_type: PostType;
  metadata_type?: string;
  tags: string[];
  category?: string;
  attachments: string[];
  status: PostStatus;
}

export interface PostUpdate {
  title?: string;
  content?: string;
  summary?: string;
  post_type?: PostType;
  metadata_type?: string;
  tags?: string[];
  category?: string;
  attachments?: string[];
  status?: PostStatus;
}

export interface PostListItem {
  id: string;
  title: string;
  slug: string;
  summary?: string;
  author: Author;
  post_type: PostType;
  tags: string[];
  stats: Stats;
  created_at: string;
  published_at?: string;
}

// 3. ì„œë¹„ìŠ¤ íƒ€ì… ì •ì˜
// frontend/app/types/service.ts
import { Post, PostCreate, PostUpdate } from './post';

export interface ServiceDetails {
  price_range?: string;
  service_area?: string[];
  contact_info?: {
    phone?: string;
    email?: string;
    website?: string;
  };
  business_hours?: {
    [key: string]: string;
  };
  rating?: number;
  review_count?: number;
}

export interface Service extends Post {
  service_details?: ServiceDetails;
}

export interface ServiceCreate extends PostCreate {
  service_details?: ServiceDetails;
}

export interface ServiceUpdate extends PostUpdate {
  service_details?: ServiceDetails;
}

// 4. íƒ€ì… ë³€í™˜ ìœ í‹¸ë¦¬í‹°
// frontend/app/utils/type-converters.ts
import { Post, PostListItem } from '~/types/post';
import { Service } from '~/types/service';

export class TypeConverter {
  /**
   * ë°±ì—”ë“œ ì‘ë‹µì„ í”„ëŸ°íŠ¸ì—”ë“œ Post íƒ€ì…ìœ¼ë¡œ ë³€í™˜
   */
  static toPost(apiResponse: any): Post {
    return {
      id: apiResponse.id || apiResponse._id,
      title: apiResponse.title,
      slug: apiResponse.slug,
      content: apiResponse.content,
      summary: apiResponse.summary,
      author: {
        id: apiResponse.author_id || apiResponse.user_id,
        name: apiResponse.author_name || apiResponse.display_name,
        email: apiResponse.author_email,
        avatar_url: apiResponse.author_avatar
      },
      post_type: apiResponse.post_type || apiResponse.metadata_type,
      status: apiResponse.status,
      metadata_type: apiResponse.metadata_type,
      tags: apiResponse.tags || [],
      category: apiResponse.category,
      stats: {
        views: apiResponse.view_count || 0,
        likes: apiResponse.like_count || apiResponse.likes || 0,
        dislikes: apiResponse.dislike_count || apiResponse.dislikes || 0,
        comments: apiResponse.comment_count || 0,
        bookmarks: apiResponse.bookmark_count || apiResponse.bookmarks || 0
      },
      attachments: apiResponse.attachments || [],
      created_at: apiResponse.created_at,
      updated_at: apiResponse.updated_at,
      published_at: apiResponse.published_at
    };
  }

  /**
   * Postë¥¼ PostListItemìœ¼ë¡œ ë³€í™˜
   */
  static toPostListItem(post: Post): PostListItem {
    return {
      id: post.id,
      title: post.title,
      slug: post.slug,
      summary: post.summary,
      author: post.author,
      post_type: post.post_type,
      tags: post.tags,
      stats: post.stats,
      created_at: post.created_at,
      published_at: post.published_at
    };
  }

  /**
   * ë°±ì—”ë“œ ì‘ë‹µì„ Service íƒ€ì…ìœ¼ë¡œ ë³€í™˜
   */
  static toService(apiResponse: any): Service {
    const post = this.toPost(apiResponse);
    
    return {
      ...post,
      service_details: apiResponse.service_details ? {
        price_range: apiResponse.service_details.price_range,
        service_area: apiResponse.service_details.service_area || [],
        contact_info: apiResponse.service_details.contact_info,
        business_hours: apiResponse.service_details.business_hours,
        rating: apiResponse.service_details.rating,
        review_count: apiResponse.service_details.review_count
      } : undefined
    };
  }

  /**
   * í”„ëŸ°íŠ¸ì—”ë“œ PostCreateë¥¼ ë°±ì—”ë“œ ìš”ì²­ í˜•ì‹ìœ¼ë¡œ ë³€í™˜
   */
  static fromPostCreate(postCreate: PostCreate): any {
    return {
      title: postCreate.title,
      content: postCreate.content,
      summary: postCreate.summary,
      post_type: postCreate.post_type,
      metadata_type: postCreate.metadata_type,
      tags: postCreate.tags,
      category: postCreate.category,
      attachments: postCreate.attachments,
      status: postCreate.status
    };
  }
}
```

##### 1.6 Context êµ¬ì¡° ìµœì í™”

**í˜„ì¬ ë¬¸ì œì :**
```typescript
// ì¤‘ì²©ëœ Provider êµ¬ì¡°
<ThemeProvider>
  <ErrorBoundary>
    <AuthProvider>
      <NotificationProvider>
        <Outlet />
      </NotificationProvider>
    </AuthProvider>
  </ErrorBoundary>
</ThemeProvider>
```

**ê°œì„  êµ¬í˜„:**
```typescript
// 1. í†µí•© ì•± ì»¨í…ìŠ¤íŠ¸ ìƒì„±
// frontend/app/contexts/AppContext.tsx
import { createContext, useContext, useReducer, ReactNode, useCallback } from 'react';
import { User } from '~/types/user';

// ì•± ìƒíƒœ íƒ€ì… ì •ì˜
interface AppState {
  // ì¸ì¦ ìƒíƒœ
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  
  // í…Œë§ˆ ìƒíƒœ
  theme: 'light' | 'dark';
  
  // ì•Œë¦¼ ìƒíƒœ
  notifications: Notification[];
  
  // UI ìƒíƒœ
  sidebarOpen: boolean;
  modalOpen: boolean;
}

// ì•¡ì…˜ íƒ€ì… ì •ì˜
type AppAction =
  | { type: 'SET_USER'; payload: User | null }
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'SET_THEME'; payload: 'light' | 'dark' }
  | { type: 'ADD_NOTIFICATION'; payload: Notification }
  | { type: 'REMOVE_NOTIFICATION'; payload: string }
  | { type: 'TOGGLE_SIDEBAR' }
  | { type: 'SET_MODAL_OPEN'; payload: boolean };

// ì´ˆê¸° ìƒíƒœ
const initialState: AppState = {
  user: null,
  isAuthenticated: false,
  isLoading: false,
  theme: 'light',
  notifications: [],
  sidebarOpen: false,
  modalOpen: false
};

// ë¦¬ë“€ì„œ í•¨ìˆ˜
function appReducer(state: AppState, action: AppAction): AppState {
  switch (action.type) {
    case 'SET_USER':
      return {
        ...state,
        user: action.payload,
        isAuthenticated: !!action.payload
      };
    
    case 'SET_LOADING':
      return {
        ...state,
        isLoading: action.payload
      };
    
    case 'SET_THEME':
      return {
        ...state,
        theme: action.payload
      };
    
    case 'ADD_NOTIFICATION':
      return {
        ...state,
        notifications: [...state.notifications, action.payload]
      };
    
    case 'REMOVE_NOTIFICATION':
      return {
        ...state,
        notifications: state.notifications.filter(n => n.id !== action.payload)
      };
    
    case 'TOGGLE_SIDEBAR':
      return {
        ...state,
        sidebarOpen: !state.sidebarOpen
      };
    
    case 'SET_MODAL_OPEN':
      return {
        ...state,
        modalOpen: action.payload
      };
    
    default:
      return state;
  }
}

// ì»¨í…ìŠ¤íŠ¸ ìƒì„±
const AppContext = createContext<{
  state: AppState;
  dispatch: React.Dispatch<AppAction>;
}>({
  state: initialState,
  dispatch: () => {}
});

// ì»¨í…ìŠ¤íŠ¸ í”„ë¡œë°”ì´ë”
export function AppProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(appReducer, initialState);
  
  return (
    <AppContext.Provider value={{ state, dispatch }}>
      {children}
    </AppContext.Provider>
  );
}

// 2. íŠ¹í™”ëœ í›… ìƒì„±
// frontend/app/hooks/useAuth.ts
import { useContext, useCallback } from 'react';
import { AppContext } from '~/contexts/AppContext';
import { User } from '~/types/user';
import { ApiClient } from '~/lib/api-client';

export function useAuth() {
  const { state, dispatch } = useContext(AppContext);
  
  const login = useCallback(async (email: string, password: string) => {
    try {
      dispatch({ type: 'SET_LOADING', payload: true });
      
      const apiClient = new ApiClient();
      const response = await apiClient.login(email, password);
      
      dispatch({ type: 'SET_USER', payload: response.user });
      
      return response;
    } catch (error) {
      throw error;
    } finally {
      dispatch({ type: 'SET_LOADING', payload: false });
    }
  }, [dispatch]);
  
  const logout = useCallback(async () => {
    try {
      dispatch({ type: 'SET_LOADING', payload: true });
      
      const apiClient = new ApiClient();
      await apiClient.logout();
      
      dispatch({ type: 'SET_USER', payload: null });
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      dispatch({ type: 'SET_LOADING', payload: false });
    }
  }, [dispatch]);
  
  const updateUser = useCallback((user: User) => {
    dispatch({ type: 'SET_USER', payload: user });
  }, [dispatch]);
  
  return {
    user: state.user,
    isAuthenticated: state.isAuthenticated,
    isLoading: state.isLoading,
    login,
    logout,
    updateUser
  };
}

// 3. í…Œë§ˆ í›…
// frontend/app/hooks/useTheme.ts
import { useContext, useCallback } from 'react';
import { AppContext } from '~/contexts/AppContext';

export function useTheme() {
  const { state, dispatch } = useContext(AppContext);
  
  const setTheme = useCallback((theme: 'light' | 'dark') => {
    dispatch({ type: 'SET_THEME', payload: theme });
    localStorage.setItem('theme', theme);
  }, [dispatch]);
  
  const toggleTheme = useCallback(() => {
    const newTheme = state.theme === 'light' ? 'dark' : 'light';
    setTheme(newTheme);
  }, [state.theme, setTheme]);
  
  return {
    theme: state.theme,
    setTheme,
    toggleTheme
  };
}

// 4. ì•Œë¦¼ í›…
// frontend/app/hooks/useNotifications.ts
import { useContext, useCallback } from 'react';
import { AppContext } from '~/contexts/AppContext';

export interface Notification {
  id: string;
  type: 'success' | 'error' | 'warning' | 'info';
  title: string;
  message: string;
  autoClose?: boolean;
  duration?: number;
}

export function useNotifications() {
  const { state, dispatch } = useContext(AppContext);
  
  const addNotification = useCallback((notification: Omit<Notification, 'id'>) => {
    const id = Date.now().toString();
    const newNotification: Notification = { ...notification, id };
    
    dispatch({ type: 'ADD_NOTIFICATION', payload: newNotification });
    
    // ìë™ ì‚­ì œ ì„¤ì •
    if (notification.autoClose !== false) {
      setTimeout(() => {
        dispatch({ type: 'REMOVE_NOTIFICATION', payload: id });
      }, notification.duration || 5000);
    }
    
    return id;
  }, [dispatch]);
  
  const removeNotification = useCallback((id: string) => {
    dispatch({ type: 'REMOVE_NOTIFICATION', payload: id });
  }, [dispatch]);
  
  const success = useCallback((title: string, message: string) => {
    return addNotification({ type: 'success', title, message });
  }, [addNotification]);
  
  const error = useCallback((title: string, message: string) => {
    return addNotification({ type: 'error', title, message, autoClose: false });
  }, [addNotification]);
  
  const warning = useCallback((title: string, message: string) => {
    return addNotification({ type: 'warning', title, message });
  }, [addNotification]);
  
  const info = useCallback((title: string, message: string) => {
    return addNotification({ type: 'info', title, message });
  }, [addNotification]);
  
  return {
    notifications: state.notifications,
    addNotification,
    removeNotification,
    success,
    error,
    warning,
    info
  };
}

// 5. ê°„ë‹¨í•œ root ì»´í¬ë„ŒíŠ¸
// frontend/app/root.tsx
import { AppProvider } from '~/contexts/AppContext';
import { Outlet } from '@remix-run/react';
import { ErrorBoundary } from '~/components/common/ErrorBoundary';
import { NotificationContainer } from '~/components/common/NotificationContainer';

export default function Root() {
  return (
    <AppProvider>
      <ErrorBoundary>
        <div className="min-h-screen bg-gray-50">
          <Outlet />
          <NotificationContainer />
        </div>
      </ErrorBoundary>
    </AppProvider>
  );
}
```

### âš¡ 2ë‹¨ê³„: ì¤‘ê¸° ê°œì„  (2-4ì£¼)

#### ë°±ì—”ë“œ - ì¤‘ê¸° ê°œì„ 

##### 2.1 ì„¤ì • ê´€ë¦¬ ê°œì„ 

**í˜„ì¬ ë¬¸ì œì :**
```python
# config.py (546ì¤„) - ëª¨ë“  ì„¤ì •ì´ í•œ íŒŒì¼ì— ì§‘ì¤‘
class Settings(BaseSettings):
    # ë„ˆë¬´ ë§ì€ ì„¤ì •ë“¤...
```

**ê°œì„  êµ¬í˜„:**
```python
# 1. ê¸°ë³¸ ì„¤ì • í´ë˜ìŠ¤
# backend/nadle_backend/config/base.py
from pydantic import BaseSettings, Field
from typing import List, Optional
import os

class BaseConfig(BaseSettings):
    """ê¸°ë³¸ ì„¤ì • í´ë˜ìŠ¤"""
    
    # ì•± ê¸°ë³¸ ì„¤ì •
    app_name: str = Field(default="Nadle Backend", env="APP_NAME")
    version: str = Field(default="1.0.0", env="APP_VERSION")
    debug: bool = Field(default=False, env="DEBUG")
    
    # ë³´ì•ˆ ì„¤ì •
    secret_key: str = Field(..., env="SECRET_KEY")
    algorithm: str = Field(default="HS256", env="ALGORITHM")
    access_token_expire_minutes: int = Field(default=30, env="ACCESS_TOKEN_EXPIRE_MINUTES")
    
    # CORS ì„¤ì •
    allowed_origins: List[str] = Field(default=["*"], env="ALLOWED_ORIGINS")
    allowed_methods: List[str] = Field(default=["*"], env="ALLOWED_METHODS")
    allowed_headers: List[str] = Field(default=["*"], env="ALLOWED_HEADERS")
    
    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"

# 2. ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •
# backend/nadle_backend/config/database.py
from .base import BaseConfig
from pydantic import Field

class DatabaseConfig(BaseConfig):
    """ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •"""
    
    # MongoDB ì„¤ì •
    mongodb_url: str = Field(..., env="MONGODB_URL")
    database_name: str = Field(..., env="DATABASE_NAME")
    
    # ì—°ê²° í’€ ì„¤ì •
    min_pool_size: int = Field(default=10, env="MIN_POOL_SIZE")
    max_pool_size: int = Field(default=100, env="MAX_POOL_SIZE")
    max_idle_time_ms: int = Field(default=60000, env="MAX_IDLE_TIME_MS")
    
    # ì¸ë±ìŠ¤ ì„¤ì •
    auto_create_indexes: bool = Field(default=True, env="AUTO_CREATE_INDEXES")

# 3. ì´ë©”ì¼ ì„¤ì •
# backend/nadle_backend/config/email.py
from .base import BaseConfig
from pydantic import Field, EmailStr

class EmailConfig(BaseConfig):
    """ì´ë©”ì¼ ì„¤ì •"""
    
    # SMTP ì„¤ì •
    smtp_host: str = Field(..., env="SMTP_HOST")
    smtp_port: int = Field(default=587, env="SMTP_PORT")
    smtp_username: str = Field(..., env="SMTP_USERNAME")
    smtp_password: str = Field(..., env="SMTP_PASSWORD")
    use_tls: bool = Field(default=True, env="SMTP_USE_TLS")
    
    # ë°œì‹ ì ì •ë³´
    from_email: EmailStr = Field(..., env="FROM_EMAIL")
    from_name: str = Field(default="Nadle", env="FROM_NAME")
    
    # í…œí”Œë¦¿ ì„¤ì •
    template_dir: str = Field(default="templates/email", env="EMAIL_TEMPLATE_DIR")

# 4. íŒŒì¼ ì—…ë¡œë“œ ì„¤ì •
# backend/nadle_backend/config/file.py
from .base import BaseConfig
from pydantic import Field
from typing import List

class FileConfig(BaseConfig):
    """íŒŒì¼ ì—…ë¡œë“œ ì„¤ì •"""
    
    # ì—…ë¡œë“œ ê²½ë¡œ
    upload_dir: str = Field(default="uploads", env="UPLOAD_DIR")
    max_file_size: int = Field(default=10 * 1024 * 1024, env="MAX_FILE_SIZE")  # 10MB
    
    # í—ˆìš© í™•ì¥ì
    allowed_extensions: List[str] = Field(
        default=["jpg", "jpeg", "png", "gif", "pdf", "doc", "docx"],
        env="ALLOWED_EXTENSIONS"
    )
    
    # ì´ë¯¸ì§€ ì²˜ë¦¬
    image_quality: int = Field(default=85, env="IMAGE_QUALITY")
    max_image_width: int = Field(default=1920, env="MAX_IMAGE_WIDTH")
    max_image_height: int = Field(default=1080, env="MAX_IMAGE_HEIGHT")

# 5. í™˜ê²½ë³„ ì„¤ì •
# backend/nadle_backend/config/development.py
from .base import BaseConfig
from .database import DatabaseConfig
from .email import EmailConfig
from .file import FileConfig

class DevelopmentConfig(BaseConfig, DatabaseConfig, EmailConfig, FileConfig):
    """ê°œë°œ í™˜ê²½ ì„¤ì •"""
    debug: bool = True
    
    # ê°œë°œ í™˜ê²½ íŠ¹í™” ì„¤ì •
    reload: bool = True
    log_level: str = "DEBUG"
    
    # í…ŒìŠ¤íŠ¸ ì´ë©”ì¼ ì„¤ì •
    smtp_host: str = "localhost"
    smtp_port: int = 1025  # MailHog ê¸°ë³¸ í¬íŠ¸

# backend/nadle_backend/config/production.py
from .base import BaseConfig
from .database import DatabaseConfig
from .email import EmailConfig
from .file import FileConfig
from pydantic import Field

class ProductionConfig(BaseConfig, DatabaseConfig, EmailConfig, FileConfig):
    """í”„ë¡œë•ì…˜ í™˜ê²½ ì„¤ì •"""
    debug: bool = False
    
    # í”„ë¡œë•ì…˜ í™˜ê²½ íŠ¹í™” ì„¤ì •
    log_level: str = "INFO"
    
    # ë³´ì•ˆ ê°•í™” ì„¤ì •
    allowed_origins: List[str] = Field(..., env="ALLOWED_ORIGINS")
    https_only: bool = Field(default=True, env="HTTPS_ONLY")
    
    # ì„±ëŠ¥ ìµœì í™” ì„¤ì •
    enable_gzip: bool = Field(default=True, env="ENABLE_GZIP")
    enable_cache: bool = Field(default=True, env="ENABLE_CACHE")

# 6. ì„¤ì • íŒ©í† ë¦¬
# backend/nadle_backend/config/__init__.py
import os
from .development import DevelopmentConfig
from .production import ProductionConfig
from .base import BaseConfig

def get_config() -> BaseConfig:
    """í™˜ê²½ì— ë”°ë¥¸ ì„¤ì • ë°˜í™˜"""
    env = os.getenv("ENVIRONMENT", "development").lower()
    
    if env == "production":
        return ProductionConfig()
    elif env == "development":
        return DevelopmentConfig()
    else:
        raise ValueError(f"Unknown environment: {env}")

# ì „ì—­ ì„¤ì • ì¸ìŠ¤í„´ìŠ¤
config = get_config()
```

##### 2.2 ì„±ëŠ¥ ìµœì í™” - ìºì‹± ì‹œìŠ¤í…œ ë„ì…

**ê°œì„  êµ¬í˜„:**
```python
# 1. ìºì‹± ì¸í„°í˜ì´ìŠ¤ ì •ì˜
# backend/nadle_backend/cache/interface.py
from abc import ABC, abstractmethod
from typing import Any, Optional, Dict, List
import json

class CacheInterface(ABC):
    """ìºì‹œ ì¸í„°í˜ì´ìŠ¤"""
    
    @abstractmethod
    async def get(self, key: str) -> Optional[Any]:
        """ìºì‹œì—ì„œ ê°’ ì¡°íšŒ"""
        pass
    
    @abstractmethod
    async def set(self, key: str, value: Any, ttl: int = 3600) -> bool:
        """ìºì‹œì— ê°’ ì €ì¥"""
        pass
    
    @abstractmethod
    async def delete(self, key: str) -> bool:
        """ìºì‹œì—ì„œ ê°’ ì‚­ì œ"""
        pass
    
    @abstractmethod
    async def clear(self) -> bool:
        """ìºì‹œ ì „ì²´ ì‚­ì œ"""
        pass

# 2. ì¸ë©”ëª¨ë¦¬ ìºì‹œ êµ¬í˜„
# backend/nadle_backend/cache/memory.py
from typing import Any, Optional, Dict
import asyncio
import time
from .interface import CacheInterface

class MemoryCache(CacheInterface):
    """ì¸ë©”ëª¨ë¦¬ ìºì‹œ êµ¬í˜„"""
    
    def __init__(self):
        self._cache: Dict[str, Dict[str, Any]] = {}
        self._lock = asyncio.Lock()
    
    async def get(self, key: str) -> Optional[Any]:
        """ìºì‹œì—ì„œ ê°’ ì¡°íšŒ"""
        async with self._lock:
            if key not in self._cache:
                return None
            
            data = self._cache[key]
            
            # TTL í™•ì¸
            if time.time() > data['expires_at']:
                del self._cache[key]
                return None
            
            return data['value']
    
    async def set(self, key: str, value: Any, ttl: int = 3600) -> bool:
        """ìºì‹œì— ê°’ ì €ì¥"""
        async with self._lock:
            self._cache[key] = {
                'value': value,
                'expires_at': time.time() + ttl
            }
            return True
    
    async def delete(self, key: str) -> bool:
        """ìºì‹œì—ì„œ ê°’ ì‚­ì œ"""
        async with self._lock:
            if key in self._cache:
                del self._cache[key]
                return True
            return False
    
    async def clear(self) -> bool:
        """ìºì‹œ ì „ì²´ ì‚­ì œ"""
        async with self._lock:
            self._cache.clear()
            return True

# 3. ìºì‹œ ë°ì½”ë ˆì´í„°
# backend/nadle_backend/cache/decorators.py
from functools import wraps
from typing import Callable, Any, Optional
import hashlib
import json
import logging
from .interface import CacheInterface

logger = logging.getLogger(__name__)

def cache_result(
    cache: CacheInterface,
    ttl: int = 3600,
    key_prefix: str = "",
    skip_cache: bool = False
):
    """ê²°ê³¼ ìºì‹± ë°ì½”ë ˆì´í„°"""
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(*args, **kwargs) -> Any:
            if skip_cache:
                return await func(*args, **kwargs)
            
            # ìºì‹œ í‚¤ ìƒì„±
            cache_key = _generate_cache_key(func, args, kwargs, key_prefix)
            
            # ìºì‹œì—ì„œ ì¡°íšŒ
            cached_result = await cache.get(cache_key)
            if cached_result is not None:
                logger.debug(f"ìºì‹œ íˆíŠ¸: {cache_key}")
                return cached_result
            
            # ìºì‹œ ë¯¸ìŠ¤ - ì‹¤ì œ í•¨ìˆ˜ ì‹¤í–‰
            logger.debug(f"ìºì‹œ ë¯¸ìŠ¤: {cache_key}")
            result = await func(*args, **kwargs)
            
            # ê²°ê³¼ ìºì‹±
            await cache.set(cache_key, result, ttl)
            
            return result
        
        return wrapper
    return decorator

def _generate_cache_key(func: Callable, args: tuple, kwargs: dict, prefix: str) -> str:
    """ìºì‹œ í‚¤ ìƒì„±"""
    # í•¨ìˆ˜ ì´ë¦„ê³¼ ì¸ìˆ˜ë¥¼ ì¡°í•©í•˜ì—¬ í‚¤ ìƒì„±
    func_name = f"{func.__module__}.{func.__name__}"
    args_str = json.dumps(args, sort_keys=True, default=str)
    kwargs_str = json.dumps(kwargs, sort_keys=True, default=str)
    
    # í•´ì‹œ ìƒì„±
    hash_input = f"{func_name}:{args_str}:{kwargs_str}"
    hash_value = hashlib.sha256(hash_input.encode()).hexdigest()[:16]
    
    return f"{prefix}:{func_name}:{hash_value}" if prefix else f"{func_name}:{hash_value}"

# 4. ìºì‹œ ì ìš© ì˜ˆì‹œ
# backend/nadle_backend/repositories/post_repository.py
from nadle_backend.cache.decorators import cache_result
from nadle_backend.cache.memory import MemoryCache

# ìºì‹œ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
post_cache = MemoryCache()

class PostRepository:
    @cache_result(cache=post_cache, ttl=300, key_prefix="post")
    async def get_popular_posts(self, limit: int = 10) -> List[Post]:
        """ì¸ê¸° ê²Œì‹œê¸€ ì¡°íšŒ (ìºì‹œ ì ìš©)"""
        logger.info(f"ì¸ê¸° ê²Œì‹œê¸€ ì¡°íšŒ: {limit}ê°œ")
        
        posts = await Post.find(
            Post.status == PostStatus.PUBLISHED
        ).sort(
            -Post.view_count, -Post.like_count
        ).limit(limit).to_list()
        
        return posts
    
    @cache_result(cache=post_cache, ttl=600, key_prefix="post_stats")
    async def get_post_stats(self, post_id: str) -> Dict[str, int]:
        """ê²Œì‹œê¸€ í†µê³„ ì¡°íšŒ (ìºì‹œ ì ìš©)"""
        logger.info(f"ê²Œì‹œê¸€ í†µê³„ ì¡°íšŒ: {post_id}")
        
        # ì§‘ê³„ ì¿¼ë¦¬ ìµœì í™”
        pipeline = [
            {"$match": {"_id": ObjectId(post_id)}},
            {"$lookup": {
                "from": "comments",
                "localField": "_id",
                "foreignField": "post_id",
                "as": "comments"
            }},
            {"$lookup": {
                "from": "user_reactions",
                "localField": "_id",
                "foreignField": "post_id",
                "as": "reactions"
            }},
            {"$project": {
                "view_count": 1,
                "comment_count": {"$size": "$comments"},
                "like_count": {
                    "$size": {
                        "$filter": {
                            "input": "$reactions",
                            "cond": {"$eq": ["$$this.reaction_type", "like"]}
                        }
                    }
                },
                "dislike_count": {
                    "$size": {
                        "$filter": {
                            "input": "$reactions",
                            "cond": {"$eq": ["$$this.reaction_type", "dislike"]}
                        }
                    }
                }
            }}
        ]
        
        result = await Post.aggregate(pipeline).to_list()
        return result[0] if result else {}
```

##### 2.3 í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ í™•ëŒ€

**ê°œì„  êµ¬í˜„:**
```python
# 1. í…ŒìŠ¤íŠ¸ íŒ©í† ë¦¬ íŒ¨í„´
# backend/tests/factories/post_factory.py
import factory
from faker import Faker
from nadle_backend.models.post import Post, PostType, PostStatus
from nadle_backend.models.user import User
from datetime import datetime

fake = Faker('ko_KR')

class UserFactory(factory.Factory):
    """ì‚¬ìš©ì íŒ©í† ë¦¬"""
    class Meta:
        model = User
    
    username = factory.Sequence(lambda n: f"user{n}")
    email = factory.LazyAttribute(lambda obj: f"{obj.username}@example.com")
    password_hash = factory.Faker('password')
    display_name = factory.Faker('name')
    bio = factory.Faker('text', max_nb_chars=200)
    is_active = True
    is_verified = True

class PostFactory(factory.Factory):
    """ê²Œì‹œê¸€ íŒ©í† ë¦¬"""
    class Meta:
        model = Post
    
    title = factory.Faker('sentence', nb_words=5)
    slug = factory.LazyAttribute(lambda obj: obj.title.lower().replace(' ', '-'))
    content = factory.Faker('text', max_nb_chars=1000)
    summary = factory.Faker('text', max_nb_chars=100)
    
    author_id = factory.LazyAttribute(lambda obj: str(fake.uuid4()))
    author_name = factory.Faker('name')
    
    post_type = factory.Faker('random_element', elements=[e.value for e in PostType])
    status = PostStatus.PUBLISHED
    
    tags = factory.LazyFunction(lambda: fake.words(nb=3))
    category = factory.Faker('word')
    
    view_count = factory.Faker('random_int', min=0, max=1000)
    like_count = factory.Faker('random_int', min=0, max=100)
    comment_count = factory.Faker('random_int', min=0, max=50)

# 2. í–¥ìƒëœ ì„œë¹„ìŠ¤ í…ŒìŠ¤íŠ¸
# backend/tests/unit/services/test_posts_service_enhanced.py
import pytest
from unittest.mock import Mock, patch, AsyncMock
from nadle_backend.services.posts_service import PostsService
from nadle_backend.repositories.post_repository import PostRepository
from nadle_backend.models.post import PostCreate, PostType, PostStatus
from nadle_backend.exceptions.post import PostNotFoundError, PostCreateError
from tests.factories.post_factory import PostFactory, UserFactory

class TestPostsServiceEnhanced:
    
    @pytest.fixture
    async def mock_post_repository(self):
        """ëª¨ì˜ ê²Œì‹œê¸€ ë ˆí¬ì§€í† ë¦¬"""
        return Mock(spec=PostRepository)
    
    @pytest.fixture
    async def posts_service(self, mock_post_repository):
        """ê²Œì‹œê¸€ ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤"""
        return PostsService(mock_post_repository)
    
    @pytest.fixture
    async def sample_post_data(self):
        """ìƒ˜í”Œ ê²Œì‹œê¸€ ë°ì´í„°"""
        return PostCreate(
            title="í…ŒìŠ¤íŠ¸ ê²Œì‹œê¸€",
            content="í…ŒìŠ¤íŠ¸ ë‚´ìš©ì…ë‹ˆë‹¤.",
            post_type=PostType.GENERAL,
            tags=["í…ŒìŠ¤íŠ¸", "ê²Œì‹œê¸€"],
            status=PostStatus.PUBLISHED
        )
    
    @pytest.fixture
    async def sample_user_id(self):
        """ìƒ˜í”Œ ì‚¬ìš©ì ID"""
        return "user123"
    
    @pytest.mark.asyncio
    async def test_create_post_success(self, posts_service, mock_post_repository, sample_post_data, sample_user_id):
        """ê²Œì‹œê¸€ ìƒì„± ì„±ê³µ í…ŒìŠ¤íŠ¸"""
        # Given
        expected_post = PostFactory.build(
            title=sample_post_data.title,
            content=sample_post_data.content,
            author_id=sample_user_id
        )
        mock_post_repository.create_post.return_value = expected_post
        mock_post_repository.get_post_by_slug.return_value = None  # ìŠ¬ëŸ¬ê·¸ ì¤‘ë³µ ì—†ìŒ
        
        # When
        result = await posts_service.create_post(sample_post_data, sample_user_id)
        
        # Then
        assert result is not None
        assert result.title == sample_post_data.title
        assert result.author_id == sample_user_id
        mock_post_repository.create_post.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_create_post_duplicate_slug(self, posts_service, mock_post_repository, sample_post_data, sample_user_id):
        """ì¤‘ë³µ ìŠ¬ëŸ¬ê·¸ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸"""
        # Given
        existing_post = PostFactory.build(title=sample_post_data.title)
        mock_post_repository.get_post_by_slug.side_effect = [
            existing_post,  # ì²« ë²ˆì§¸ ìŠ¬ëŸ¬ê·¸ ì¤‘ë³µ
            None  # ë‘ ë²ˆì§¸ ìŠ¬ëŸ¬ê·¸ ì‚¬ìš© ê°€ëŠ¥
        ]
        
        expected_post = PostFactory.build()
        mock_post_repository.create_post.return_value = expected_post
        
        # When
        result = await posts_service.create_post(sample_post_data, sample_user_id)
        
        # Then
        assert result is not None
        assert mock_post_repository.get_post_by_slug.call_count == 2
        mock_post_repository.create_post.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_create_post_repository_error(self, posts_service, mock_post_repository, sample_post_data, sample_user_id):
        """ë ˆí¬ì§€í† ë¦¬ ì˜¤ë¥˜ ì‹œ ì˜ˆì™¸ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸"""
        # Given
        mock_post_repository.get_post_by_slug.return_value = None
        mock_post_repository.create_post.side_effect = Exception("Database error")
        
        # When & Then
        with pytest.raises(PostCreateError) as exc_info:
            await posts_service.create_post(sample_post_data, sample_user_id)
        
        assert "ê²Œì‹œê¸€ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" in str(exc_info.value)
    
    @pytest.mark.asyncio
    async def test_get_post_by_slug_success(self, posts_service, mock_post_repository):
        """ìŠ¬ëŸ¬ê·¸ë¡œ ê²Œì‹œê¸€ ì¡°íšŒ ì„±ê³µ í…ŒìŠ¤íŠ¸"""
        # Given
        slug = "test-post"
        expected_post = PostFactory.build(slug=slug)
        mock_post_repository.get_post_by_slug.return_value = expected_post
        
        # When
        result = await posts_service.get_post_by_slug(slug)
        
        # Then
        assert result is not None
        assert result.slug == slug
        mock_post_repository.get_post_by_slug.assert_called_once_with(slug)
    
    @pytest.mark.asyncio
    async def test_get_post_by_slug_not_found(self, posts_service, mock_post_repository):
        """ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²Œì‹œê¸€ ì¡°íšŒ í…ŒìŠ¤íŠ¸"""
        # Given
        slug = "nonexistent-post"
        mock_post_repository.get_post_by_slug.return_value = None
        
        # When & Then
        with pytest.raises(PostNotFoundError):
            await posts_service.get_post_by_slug(slug)
    
    @pytest.mark.asyncio
    @patch('nadle_backend.utils.post_utils.normalize_post_type')
    async def test_create_post_metadata_processing(self, mock_normalize, posts_service, mock_post_repository, sample_post_data, sample_user_id):
        """ë©”íƒ€ë°ì´í„° ì²˜ë¦¬ í…ŒìŠ¤íŠ¸"""
        # Given
        sample_post_data.metadata_type = "moving services"
        mock_normalize.return_value = "moving_service"
        
        expected_post = PostFactory.build()
        mock_post_repository.get_post_by_slug.return_value = None
        mock_post_repository.create_post.return_value = expected_post
        
        # When
        await posts_service.create_post(sample_post_data, sample_user_id)
        
        # Then
        mock_normalize.assert_called_once_with("moving services")
        mock_post_repository.create_post.assert_called_once()
        
        # ë ˆí¬ì§€í† ë¦¬ í˜¸ì¶œ ì‹œ ì •ê·œí™”ëœ ë©”íƒ€ë°ì´í„° íƒ€ì…ì´ ì‚¬ìš©ë˜ì—ˆëŠ”ì§€ í™•ì¸
        call_args = mock_post_repository.create_post.call_args[0][0]
        assert call_args["metadata_type"] == "moving_service"

# 3. í†µí•© í…ŒìŠ¤íŠ¸ ì˜ˆì‹œ
# backend/tests/integration/test_posts_api_integration.py
import pytest
from httpx import AsyncClient
from fastapi.testclient import TestClient
from nadle_backend.main import app
from nadle_backend.dependencies.auth import get_current_user
from tests.factories.post_factory import UserFactory, PostFactory

class TestPostsAPIIntegration:
    
    @pytest.fixture
    async def authenticated_client(self):
        """ì¸ì¦ëœ í´ë¼ì´ì–¸íŠ¸"""
        # ì¸ì¦ ì˜ì¡´ì„± ëª¨ì˜
        test_user = UserFactory.build()
        app.dependency_overrides[get_current_user] = lambda: test_user
        
        client = TestClient(app)
        yield client
        
        # ì˜ì¡´ì„± ì˜¤ë²„ë¼ì´ë“œ ì œê±°
        app.dependency_overrides.clear()
    
    @pytest.mark.asyncio
    async def test_create_post_end_to_end(self, authenticated_client):
        """ê²Œì‹œê¸€ ìƒì„± E2E í…ŒìŠ¤íŠ¸"""
        # Given
        post_data = {
            "title": "í†µí•© í…ŒìŠ¤íŠ¸ ê²Œì‹œê¸€",
            "content": "í†µí•© í…ŒìŠ¤íŠ¸ ë‚´ìš©ì…ë‹ˆë‹¤.",
            "post_type": "general",
            "tags": ["í†µí•©í…ŒìŠ¤íŠ¸", "E2E"],
            "status": "published"
        }
        
        # When
        response = authenticated_client.post("/api/posts", json=post_data)
        
        # Then
        assert response.status_code == 201
        response_data = response.json()
        assert response_data["title"] == post_data["title"]
        assert response_data["content"] == post_data["content"]
        assert "id" in response_data
        assert "slug" in response_data
        assert "created_at" in response_data
    
    @pytest.mark.asyncio
    async def test_get_posts_pagination(self, authenticated_client):
        """ê²Œì‹œê¸€ ëª©ë¡ ì¡°íšŒ í˜ì´ì§€ë„¤ì´ì…˜ í…ŒìŠ¤íŠ¸"""
        # Given
        page = 1
        size = 10
        
        # When
        response = authenticated_client.get(f"/api/posts?page={page}&size={size}")
        
        # Then
        assert response.status_code == 200
        response_data = response.json()
        assert "items" in response_data
        assert "total" in response_data
        assert "page" in response_data
        assert "size" in response_data
        assert response_data["page"] == page
        assert response_data["size"] == size
        assert len(response_data["items"]) <= size
```

#### í”„ëŸ°íŠ¸ì—”ë“œ - ì¤‘ê¸° ê°œì„ 

##### 2.4 API í´ë¼ì´ì–¸íŠ¸ ë¶„í• 

**í˜„ì¬ ë¬¸ì œì :**
```typescript
// ë‹¨ì¼ ê±°ëŒ€ í´ë˜ìŠ¤ (900+ ë¼ì¸)
class ApiClient {
  // ì¸ì¦, API í˜¸ì¶œ, ì„¸ì…˜ ê´€ë¦¬ ëª¨ë“  ê²ƒì„ ë‹´ë‹¹
}
```

**ê°œì„  êµ¬í˜„:**
```typescript
// 1. ê¸°ë³¸ HTTP í´ë¼ì´ì–¸íŠ¸
// frontend/app/lib/http-client.ts
import { Notification } from '~/hooks/useNotifications';

export interface HttpConfig {
  baseURL: string;
  timeout: number;
  retries: number;
  headers: Record<string, string>;
}

export interface HttpResponse<T = any> {
  data: T;
  status: number;
  statusText: string;
  headers: Record<string, string>;
}

export class HttpClient {
  private config: HttpConfig;
  private interceptors: {
    request: Array<(config: RequestInit) => RequestInit>;
    response: Array<(response: Response) => Promise<Response>>;
  };

  constructor(config: Partial<HttpConfig> = {}) {
    this.config = {
      baseURL: config.baseURL || process.env.API_BASE_URL || 'http://localhost:8000',
      timeout: config.timeout || 30000,
      retries: config.retries || 3,
      headers: config.headers || {}
    };
    
    this.interceptors = {
      request: [],
      response: []
    };
  }

  // ìš”ì²­ ì¸í„°ì…‰í„° ì¶”ê°€
  addRequestInterceptor(interceptor: (config: RequestInit) => RequestInit) {
    this.interceptors.request.push(interceptor);
  }

  // ì‘ë‹µ ì¸í„°ì…‰í„° ì¶”ê°€
  addResponseInterceptor(interceptor: (response: Response) => Promise<Response>) {
    this.interceptors.response.push(interceptor);
  }

  // HTTP ë©”ì„œë“œë“¤
  async get<T = any>(url: string, config?: RequestInit): Promise<HttpResponse<T>> {
    return this.request<T>(url, { ...config, method: 'GET' });
  }

  async post<T = any>(url: string, data?: any, config?: RequestInit): Promise<HttpResponse<T>> {
    return this.request<T>(url, { 
      ...config, 
      method: 'POST', 
      body: JSON.stringify(data),
      headers: {
        'Content-Type': 'application/json',
        ...config?.headers
      }
    });
  }

  async put<T = any>(url: string, data?: any, config?: RequestInit): Promise<HttpResponse<T>> {
    return this.request<T>(url, { 
      ...config, 
      method: 'PUT', 
      body: JSON.stringify(data),
      headers: {
        'Content-Type': 'application/json',
        ...config?.headers
      }
    });
  }

  async delete<T = any>(url: string, config?: RequestInit): Promise<HttpResponse<T>> {
    return this.request<T>(url, { ...config, method: 'DELETE' });
  }

  // ê¸°ë³¸ ìš”ì²­ ë©”ì„œë“œ
  private async request<T>(url: string, config: RequestInit): Promise<HttpResponse<T>> {
    const fullUrl = `${this.config.baseURL}${url}`;
    let requestConfig = {
      ...config,
      headers: {
        ...this.config.headers,
        ...config.headers
      }
    };

    // ìš”ì²­ ì¸í„°ì…‰í„° ì ìš©
    for (const interceptor of this.interceptors.request) {
      requestConfig = interceptor(requestConfig);
    }

    let response: Response;
    let attempts = 0;
    
    while (attempts < this.config.retries) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);

        response = await fetch(fullUrl, {
          ...requestConfig,
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        // ì‘ë‹µ ì¸í„°ì…‰í„° ì ìš©
        for (const interceptor of this.interceptors.response) {
          response = await interceptor(response);
        }

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        return {
          data,
          status: response.status,
          statusText: response.statusText,
          headers: Object.fromEntries(response.headers.entries())
        };

      } catch (error) {
        attempts++;
        if (attempts >= this.config.retries) {
          throw error;
        }
        
        // ì§€ìˆ˜ ë°±ì˜¤í”„
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempts) * 1000));
      }
    }

    throw new Error('Max retries exceeded');
  }
}

// 2. ì¸ì¦ ì„œë¹„ìŠ¤
// frontend/app/services/auth-service.ts
import { HttpClient, HttpResponse } from '~/lib/http-client';
import { User } from '~/types/user';

export interface LoginRequest {
  email: string;
  password: string;
}

export interface LoginResponse {
  user: User;
  access_token: string;
  refresh_token: string;
}

export interface RegisterRequest {
  username: string;
  email: string;
  password: string;
  display_name?: string;
}

export class AuthService {
  private httpClient: HttpClient;

  constructor(httpClient: HttpClient) {
    this.httpClient = httpClient;
  }

  async login(credentials: LoginRequest): Promise<LoginResponse> {
    const response = await this.httpClient.post<LoginResponse>('/api/auth/login', credentials);
    
    // í† í° ì €ì¥
    localStorage.setItem('access_token', response.data.access_token);
    localStorage.setItem('refresh_token', response.data.refresh_token);
    
    return response.data;
  }

  async register(userData: RegisterRequest): Promise<User> {
    const response = await this.httpClient.post<User>('/api/auth/register', userData);
    return response.data;
  }

  async logout(): Promise<void> {
    try {
      await this.httpClient.post('/api/auth/logout');
    } finally {
      // ë¡œì»¬ í† í° ì‚­ì œ
      localStorage.removeItem('access_token');
      localStorage.removeItem('refresh_token');
    }
  }

  async refreshToken(): Promise<string> {
    const refreshToken = localStorage.getItem('refresh_token');
    if (!refreshToken) {
      throw new Error('No refresh token available');
    }

    const response = await this.httpClient.post<{ access_token: string }>('/api/auth/refresh', {
      refresh_token: refreshToken
    });

    const newToken = response.data.access_token;
    localStorage.setItem('access_token', newToken);
    
    return newToken;
  }

  async getCurrentUser(): Promise<User> {
    const response = await this.httpClient.get<User>('/api/auth/me');
    return response.data;
  }

  getStoredToken(): string | null {
    return localStorage.getItem('access_token');
  }
}

// 3. ê²Œì‹œê¸€ ì„œë¹„ìŠ¤
// frontend/app/services/posts-service.ts
import { HttpClient } from '~/lib/http-client';
import { Post, PostCreate, PostUpdate, PostListItem } from '~/types/post';
import { PaginationParams, PaginationResponse } from '~/types/common';

export interface PostsFilter {
  post_type?: string;
  metadata_type?: string;
  category?: string;
  tags?: string[];
  author_id?: string;
  status?: string;
}

export interface PostsSort {
  field: string;
  direction: 'asc' | 'desc';
}

export class PostsService {
  private httpClient: HttpClient;

  constructor(httpClient: HttpClient) {
    this.httpClient = httpClient;
  }

  async getPosts(
    pagination: PaginationParams = { page: 1, size: 20 },
    filter: PostsFilter = {},
    sort: PostsSort = { field: 'created_at', direction: 'desc' }
  ): Promise<PaginationResponse<PostListItem>> {
    const params = new URLSearchParams({
      page: pagination.page.toString(),
      size: pagination.size.toString(),
      sort_field: sort.field,
      sort_direction: sort.direction,
      ...filter
    });

    const response = await this.httpClient.get<PaginationResponse<PostListItem>>(
      `/api/posts?${params.toString()}`
    );

    return response.data;
  }

  async getPost(slug: string): Promise<Post> {
    const response = await this.httpClient.get<Post>(`/api/posts/${slug}`);
    return response.data;
  }

  async createPost(postData: PostCreate): Promise<Post> {
    const response = await this.httpClient.post<Post>('/api/posts', postData);
    return response.data;
  }

  async updatePost(slug: string, postData: PostUpdate): Promise<Post> {
    const response = await this.httpClient.put<Post>(`/api/posts/${slug}`, postData);
    return response.data;
  }

  async deletePost(slug: string): Promise<void> {
    await this.httpClient.delete(`/api/posts/${slug}`);
  }

  async likePost(slug: string): Promise<void> {
    await this.httpClient.post(`/api/posts/${slug}/like`);
  }

  async unlikePost(slug: string): Promise<void> {
    await this.httpClient.delete(`/api/posts/${slug}/like`);
  }

  async bookmarkPost(slug: string): Promise<void> {
    await this.httpClient.post(`/api/posts/${slug}/bookmark`);
  }

  async unbookmarkPost(slug: string): Promise<void> {
    await this.httpClient.delete(`/api/posts/${slug}/bookmark`);
  }

  async getPopularPosts(limit: number = 10): Promise<PostListItem[]> {
    const response = await this.httpClient.get<PostListItem[]>(
      `/api/posts/popular?limit=${limit}`
    );
    return response.data;
  }

  async getRelatedPosts(slug: string, limit: number = 5): Promise<PostListItem[]> {
    const response = await this.httpClient.get<PostListItem[]>(
      `/api/posts/${slug}/related?limit=${limit}`
    );
    return response.data;
  }
}

// 4. ì„œë¹„ìŠ¤ íŒ©í† ë¦¬
// frontend/app/services/index.ts
import { HttpClient } from '~/lib/http-client';
import { AuthService } from './auth-service';
import { PostsService } from './posts-service';
import { CommentsService } from './comments-service';
import { FilesService } from './files-service';

export class ServiceFactory {
  private httpClient: HttpClient;
  private authService: AuthService;
  private postsService: PostsService;
  private commentsService: CommentsService;
  private filesService: FilesService;

  constructor() {
    this.httpClient = new HttpClient();
    this.setupInterceptors();
    
    this.authService = new AuthService(this.httpClient);
    this.postsService = new PostsService(this.httpClient);
    this.commentsService = new CommentsService(this.httpClient);
    this.filesService = new FilesService(this.httpClient);
  }

  private setupInterceptors() {
    // ìš”ì²­ ì¸í„°ì…‰í„°: í† í° ì¶”ê°€
    this.httpClient.addRequestInterceptor((config) => {
      const token = this.authService.getStoredToken();
      if (token) {
        config.headers = {
          ...config.headers,
          'Authorization': `Bearer ${token}`
        };
      }
      return config;
    });

    // ì‘ë‹µ ì¸í„°ì…‰í„°: í† í° ë§Œë£Œ ì²˜ë¦¬
    this.httpClient.addResponseInterceptor(async (response) => {
      if (response.status === 401) {
        try {
          // í† í° ê°±ì‹  ì‹œë„
          await this.authService.refreshToken();
          
          // ì›ë˜ ìš”ì²­ ì¬ì‹œë„
          const originalRequest = response.url;
          return fetch(originalRequest);
        } catch (error) {
          // í† í° ê°±ì‹  ì‹¤íŒ¨ ì‹œ ë¡œê·¸ì•„ì›ƒ
          await this.authService.logout();
          window.location.href = '/auth/login';
        }
      }
      return response;
    });
  }

  getAuthService(): AuthService {
    return this.authService;
  }

  getPostsService(): PostsService {
    return this.postsService;
  }

  getCommentsService(): CommentsService {
    return this.commentsService;
  }

  getFilesService(): FilesService {
    return this.filesService;
  }
}

// ì „ì—­ ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤
export const serviceFactory = new ServiceFactory();
export const authService = serviceFactory.getAuthService();
export const postsService = serviceFactory.getPostsService();
export const commentsService = serviceFactory.getCommentsService();
export const filesService = serviceFactory.getFilesService();
```

##### 2.5 ì„±ëŠ¥ ìµœì í™”

**ê°œì„  êµ¬í˜„:**
```typescript
// 1. ì´ë¯¸ì§€ ìµœì í™” ì»´í¬ë„ŒíŠ¸
// frontend/app/components/common/OptimizedImage.tsx
import { useState, useCallback } from 'react';
import { useInView } from 'react-intersection-observer';

interface OptimizedImageProps {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  className?: string;
  quality?: number;
  priority?: boolean;
  onLoad?: () => void;
  onError?: () => void;
}

export function OptimizedImage({
  src,
  alt,
  width,
  height,
  className = '',
  quality = 85,
  priority = false,
  onLoad,
  onError
}: OptimizedImageProps) {
  const [isLoaded, setIsLoaded] = useState(false);
  const [hasError, setHasError] = useState(false);
  const { ref, inView } = useInView({
    triggerOnce: true,
    threshold: 0.1,
    skip: priority // ìš°ì„ ìˆœìœ„ ì´ë¯¸ì§€ëŠ” ì§€ì—° ë¡œë”© ìŠ¤í‚µ
  });

  const handleLoad = useCallback(() => {
    setIsLoaded(true);
    onLoad?.();
  }, [onLoad]);

  const handleError = useCallback(() => {
    setHasError(true);
    onError?.();
  }, [onError]);

  // ì´ë¯¸ì§€ URL ìµœì í™”
  const optimizedSrc = useCallback((src: string, width?: number, height?: number, quality?: number) => {
    if (!src.includes('http')) {
      return src; // ìƒëŒ€ ê²½ë¡œëŠ” ê·¸ëŒ€ë¡œ ë°˜í™˜
    }

    const url = new URL(src);
    
    // ì´ë¯¸ì§€ ìµœì í™” íŒŒë¼ë¯¸í„° ì¶”ê°€
    if (width) url.searchParams.set('w', width.toString());
    if (height) url.searchParams.set('h', height.toString());
    if (quality) url.searchParams.set('q', quality.toString());
    
    return url.toString();
  }, []);

  // ì§€ì—° ë¡œë”© ì¡°ê±´ í™•ì¸
  const shouldLoad = priority || inView;

  return (
    <div
      ref={ref}
      className={`relative overflow-hidden ${className}`}
      style={{ width, height }}
    >
      {shouldLoad && !hasError ? (
        <img
          src={optimizedSrc(src, width, height, quality)}
          alt={alt}
          className={`transition-opacity duration-300 ${
            isLoaded ? 'opacity-100' : 'opacity-0'
          }`}
          onLoad={handleLoad}
          onError={handleError}
          loading={priority ? 'eager' : 'lazy'}
        />
      ) : hasError ? (
        <div className="flex items-center justify-center w-full h-full bg-gray-200">
          <span className="text-gray-500">ì´ë¯¸ì§€ ë¡œë”© ì‹¤íŒ¨</span>
        </div>
      ) : (
        <div className="animate-pulse bg-gray-200 w-full h-full" />
      )}
    </div>
  );
}

// 2. ê°€ìƒí™”ëœ ë¦¬ìŠ¤íŠ¸ ì»´í¬ë„ŒíŠ¸
// frontend/app/components/common/VirtualizedList.tsx
import { useVirtualizer } from '@tanstack/react-virtual';
import { useRef, useMemo } from 'react';

interface VirtualizedListProps<T> {
  items: T[];
  renderItem: (item: T, index: number) => React.ReactNode;
  itemHeight: number;
  containerHeight: number;
  className?: string;
  overscan?: number;
}

export function VirtualizedList<T>({
  items,
  renderItem,
  itemHeight,
  containerHeight,
  className = '',
  overscan = 5
}: VirtualizedListProps<T>) {
  const parentRef = useRef<HTMLDivElement>(null);

  const virtualizer = useVirtualizer({
    count: items.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => itemHeight,
    overscan
  });

  const virtualItems = virtualizer.getVirtualItems();

  return (
    <div
      ref={parentRef}
      className={`overflow-auto ${className}`}
      style={{ height: containerHeight }}
    >
      <div
        style={{
          height: virtualizer.getTotalSize(),
          width: '100%',
          position: 'relative'
        }}
      >
        {virtualItems.map((virtualItem) => (
          <div
            key={virtualItem.key}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: virtualItem.size,
              transform: `translateY(${virtualItem.start}px)`
            }}
          >
            {renderItem(items[virtualItem.index], virtualItem.index)}
          </div>
        ))}
      </div>
    </div>
  );
}

// 3. ë©”ëª¨ì´ì œì´ì…˜ëœ ë¦¬ìŠ¤íŠ¸ ì•„ì´í…œ
// frontend/app/components/post/PostListItem.tsx
import { memo, useCallback } from 'react';
import { Post } from '~/types/post';
import { OptimizedImage } from '~/components/common/OptimizedImage';

interface PostListItemProps {
  post: Post;
  onLike?: (postId: string) => void;
  onBookmark?: (postId: string) => void;
  onClick?: (post: Post) => void;
}

export const PostListItem = memo(function PostListItem({
  post,
  onLike,
  onBookmark,
  onClick
}: PostListItemProps) {
  const handleLike = useCallback(() => {
    onLike?.(post.id);
  }, [post.id, onLike]);

  const handleBookmark = useCallback(() => {
    onBookmark?.(post.id);
  }, [post.id, onBookmark]);

  const handleClick = useCallback(() => {
    onClick?.(post);
  }, [post, onClick]);

  return (
    <article className="bg-white rounded-lg shadow-sm hover:shadow-md transition-shadow duration-200 cursor-pointer">
      <div className="p-6" onClick={handleClick}>
        {/* ì¸ë„¤ì¼ ì´ë¯¸ì§€ */}
        {post.thumbnail && (
          <OptimizedImage
            src={post.thumbnail}
            alt={post.title}
            width={300}
            height={200}
            className="w-full h-48 object-cover rounded-lg mb-4"
          />
        )}

        {/* ê²Œì‹œê¸€ ì œëª© */}
        <h3 className="text-lg font-semibold mb-2 line-clamp-2">
          {post.title}
        </h3>

        {/* ê²Œì‹œê¸€ ìš”ì•½ */}
        {post.summary && (
          <p className="text-gray-600 mb-3 line-clamp-3">
            {post.summary}
          </p>
        )}

        {/* ë©”íƒ€ ì •ë³´ */}
        <div className="flex items-center justify-between text-sm text-gray-500">
          <div className="flex items-center space-x-2">
            <span>{post.author.name}</span>
            <span>â€¢</span>
            <span>{formatDate(post.created_at)}</span>
          </div>
          
          <div className="flex items-center space-x-4">
            <button
              onClick={(e) => {
                e.stopPropagation();
                handleLike();
              }}
              className="flex items-center space-x-1 hover:text-red-500 transition-colors"
            >
              <span>â™¥</span>
              <span>{post.stats.likes}</span>
            </button>
            
            <button
              onClick={(e) => {
                e.stopPropagation();
                handleBookmark();
              }}
              className="flex items-center space-x-1 hover:text-blue-500 transition-colors"
            >
              <span>â˜…</span>
              <span>{post.stats.bookmarks}</span>
            </button>
          </div>
        </div>
      </div>
    </article>
  );
});

function formatDate(dateString: string): string {
  const date = new Date(dateString);
  const now = new Date();
  const diffInMs = now.getTime() - date.getTime();
  const diffInDays = Math.floor(diffInMs / (1000 * 60 * 60 * 24));
  
  if (diffInDays === 0) {
    return 'ì˜¤ëŠ˜';
  } else if (diffInDays === 1) {
    return 'ì–´ì œ';
  } else if (diffInDays < 7) {
    return `${diffInDays}ì¼ ì „`;
  } else {
    return date.toLocaleDateString('ko-KR');
  }
}

// 4. ì½”ë“œ ë¶„í•  ì˜ˆì‹œ
// frontend/app/routes/posts._index.tsx
import { lazy, Suspense } from 'react';
import { LoaderFunctionArgs } from '@remix-run/node';
import { useLoaderData } from '@remix-run/react';
import { PostListItem } from '~/components/post/PostListItem';
import { VirtualizedList } from '~/components/common/VirtualizedList';

// ì§€ì—° ë¡œë”© ì»´í¬ë„ŒíŠ¸
const PostFilters = lazy(() => import('~/components/post/PostFilters'));
const PostSort = lazy(() => import('~/components/post/PostSort'));

export async function loader({ request }: LoaderFunctionArgs) {
  const url = new URL(request.url);
  const page = Number(url.searchParams.get('page')) || 1;
  const size = Number(url.searchParams.get('size')) || 20;
  
  // ê²Œì‹œê¸€ ëª©ë¡ ì¡°íšŒ
  const posts = await postsService.getPosts({ page, size });
  
  return { posts };
}

export default function PostsIndex() {
  const { posts } = useLoaderData<typeof loader>();

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex gap-8">
        {/* ì‚¬ì´ë“œë°” - ì§€ì—° ë¡œë”© */}
        <aside className="w-64 flex-shrink-0">
          <Suspense fallback={<div className="animate-pulse bg-gray-200 h-40 rounded" />}>
            <PostFilters />
          </Suspense>
          
          <Suspense fallback={<div className="animate-pulse bg-gray-200 h-20 rounded mt-4" />}>
            <PostSort />
          </Suspense>
        </aside>

        {/* ë©”ì¸ ì»¨í…ì¸  */}
        <main className="flex-1">
          <VirtualizedList
            items={posts.items}
            renderItem={(post, index) => (
              <PostListItem
                key={post.id}
                post={post}
                onLike={handleLike}
                onBookmark={handleBookmark}
                onClick={handlePostClick}
              />
            )}
            itemHeight={300}
            containerHeight={600}
            className="space-y-4"
          />
        </main>
      </div>
    </div>
  );
}

function handleLike(postId: string) {
  // ì¢‹ì•„ìš” ì²˜ë¦¬
}

function handleBookmark(postId: string) {
  // ë¶ë§ˆí¬ ì²˜ë¦¬
}

function handlePostClick(post: Post) {
  // ê²Œì‹œê¸€ í´ë¦­ ì²˜ë¦¬
}
```

### ğŸš€ 3ë‹¨ê³„: ì¥ê¸° ê°œì„  (1-2ê°œì›”)

#### 3.1 ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ êµ¬ì¶•

**ê°œì„  êµ¬í˜„:**
```python
# 1. ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë¯¸ë“¤ì›¨ì–´
# backend/nadle_backend/middleware/monitoring.py
import time
import logging
from typing import Callable
from fastapi import Request, Response
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.types import ASGIApp

logger = logging.getLogger(__name__)

class MonitoringMiddleware(BaseHTTPMiddleware):
    """ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë¯¸ë“¤ì›¨ì–´"""
    
    def __init__(self, app: ASGIApp):
        super().__init__(app)
        self.slow_query_threshold = 1.0  # 1ì´ˆ ì´ìƒ ê±¸ë¦¬ë©´ ëŠë¦° ì¿¼ë¦¬ë¡œ ê¸°ë¡
    
    async def dispatch(self, request: Request, call_next: Callable) -> Response:
        start_time = time.time()
        
        # ìš”ì²­ ì‹œì‘ ë¡œê·¸
        logger.info(f"ìš”ì²­ ì‹œì‘: {request.method} {request.url}")
        
        try:
            response = await call_next(request)
            
            # ì‘ë‹µ ì‹œê°„ ê³„ì‚°
            process_time = time.time() - start_time
            
            # ì‘ë‹µ í—¤ë”ì— ì²˜ë¦¬ ì‹œê°„ ì¶”ê°€
            response.headers["X-Process-Time"] = str(process_time)
            
            # ì„±ëŠ¥ ë¡œê¹…
            if process_time > self.slow_query_threshold:
                logger.warning(
                    f"ëŠë¦° ìš”ì²­ ê°ì§€: {request.method} {request.url} - {process_time:.2f}ì´ˆ"
                )
            else:
                logger.info(
                    f"ìš”ì²­ ì™„ë£Œ: {request.method} {request.url} - {process_time:.2f}ì´ˆ"
                )
            
            return response
            
        except Exception as e:
            process_time = time.time() - start_time
            
            logger.error(
                f"ìš”ì²­ ì˜¤ë¥˜: {request.method} {request.url} - {process_time:.2f}ì´ˆ - {str(e)}"
            )
            
            raise

# 2. ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹œìŠ¤í…œ
# backend/nadle_backend/monitoring/metrics.py
from dataclasses import dataclass
from typing import Dict, List, Optional
from datetime import datetime, timedelta
import asyncio

@dataclass
class Metric:
    name: str
    value: float
    timestamp: datetime
    tags: Dict[str, str]

class MetricsCollector:
    """ë©”íŠ¸ë¦­ ìˆ˜ì§‘ê¸°"""
    
    def __init__(self):
        self.metrics: List[Metric] = []
        self.counters: Dict[str, int] = {}
        self.gauges: Dict[str, float] = {}
        self.histograms: Dict[str, List[float]] = {}
    
    def counter(self, name: str, value: int = 1, tags: Dict[str, str] = None):
        """ì¹´ìš´í„° ë©”íŠ¸ë¦­"""
        key = f"{name}:{tags or {}}"
        self.counters[key] = self.counters.get(key, 0) + value
        
        self.metrics.append(Metric(
            name=name,
            value=value,
            timestamp=datetime.utcnow(),
            tags=tags or {}
        ))
    
    def gauge(self, name: str, value: float, tags: Dict[str, str] = None):
        """ê²Œì´ì§€ ë©”íŠ¸ë¦­"""
        key = f"{name}:{tags or {}}"
        self.gauges[key] = value
        
        self.metrics.append(Metric(
            name=name,
            value=value,
            timestamp=datetime.utcnow(),
            tags=tags or {}
        ))
    
    def histogram(self, name: str, value: float, tags: Dict[str, str] = None):
        """íˆìŠ¤í† ê·¸ë¨ ë©”íŠ¸ë¦­"""
        key = f"{name}:{tags or {}}"
        if key not in self.histograms:
            self.histograms[key] = []
        self.histograms[key].append(value)
        
        self.metrics.append(Metric(
            name=name,
            value=value,
            timestamp=datetime.utcnow(),
            tags=tags or {}
        ))
    
    def get_metrics(self, since: Optional[datetime] = None) -> List[Metric]:
        """ë©”íŠ¸ë¦­ ì¡°íšŒ"""
        if since is None:
            return self.metrics
        
        return [m for m in self.metrics if m.timestamp >= since]
    
    def clear_old_metrics(self, older_than: timedelta = timedelta(hours=1)):
        """ì˜¤ë˜ëœ ë©”íŠ¸ë¦­ ì •ë¦¬"""
        cutoff = datetime.utcnow() - older_than
        self.metrics = [m for m in self.metrics if m.timestamp >= cutoff]

# ê¸€ë¡œë²Œ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ê¸°
metrics_collector = MetricsCollector()

# 3. í—¬ìŠ¤ ì²´í¬ ì‹œìŠ¤í…œ
# backend/nadle_backend/health/checks.py
from abc import ABC, abstractmethod
from typing import Dict, Any, List
from enum import Enum
import asyncio
from nadle_backend.database.connection import get_database

class HealthStatus(Enum):
    HEALTHY = "healthy"
    UNHEALTHY = "unhealthy"
    DEGRADED = "degraded"

class HealthCheck(ABC):
    """í—¬ìŠ¤ ì²´í¬ ì¸í„°í˜ì´ìŠ¤"""
    
    @abstractmethod
    async def check(self) -> Dict[str, Any]:
        pass
    
    @property
    @abstractmethod
    def name(self) -> str:
        pass

class DatabaseHealthCheck(HealthCheck):
    """ë°ì´í„°ë² ì´ìŠ¤ í—¬ìŠ¤ ì²´í¬"""
    
    @property
    def name(self) -> str:
        return "database"
    
    async def check(self) -> Dict[str, Any]:
        try:
            db = await get_database()
            # ê°„ë‹¨í•œ ping ëª…ë ¹
            await db.command("ping")
            
            return {
                "status": HealthStatus.HEALTHY.value,
                "message": "Database connection is healthy",
                "response_time": 0.1  # ì‹¤ì œ ì‘ë‹µ ì‹œê°„ ì¸¡ì •
            }
        except Exception as e:
            return {
                "status": HealthStatus.UNHEALTHY.value,
                "message": f"Database connection failed: {str(e)}",
                "error": str(e)
            }

class MemoryHealthCheck(HealthCheck):
    """ë©”ëª¨ë¦¬ í—¬ìŠ¤ ì²´í¬"""
    
    @property
    def name(self) -> str:
        return "memory"
    
    async def check(self) -> Dict[str, Any]:
        import psutil
        
        memory = psutil.virtual_memory()
        
        if memory.percent > 90:
            status = HealthStatus.UNHEALTHY
            message = "Memory usage is critically high"
        elif memory.percent > 80:
            status = HealthStatus.DEGRADED
            message = "Memory usage is high"
        else:
            status = HealthStatus.HEALTHY
            message = "Memory usage is normal"
        
        return {
            "status": status.value,
            "message": message,
            "memory_percent": memory.percent,
            "memory_available": memory.available,
            "memory_total": memory.total
        }

class HealthCheckService:
    """í—¬ìŠ¤ ì²´í¬ ì„œë¹„ìŠ¤"""
    
    def __init__(self):
        self.checks: List[HealthCheck] = [
            DatabaseHealthCheck(),
            MemoryHealthCheck()
        ]
    
    async def run_all_checks(self) -> Dict[str, Any]:
        """ëª¨ë“  í—¬ìŠ¤ ì²´í¬ ì‹¤í–‰"""
        results = {}
        overall_status = HealthStatus.HEALTHY
        
        for check in self.checks:
            try:
                result = await check.check()
                results[check.name] = result
                
                # ì „ì²´ ìƒíƒœ ê²°ì •
                if result["status"] == HealthStatus.UNHEALTHY.value:
                    overall_status = HealthStatus.UNHEALTHY
                elif (result["status"] == HealthStatus.DEGRADED.value and 
                      overall_status == HealthStatus.HEALTHY):
                    overall_status = HealthStatus.DEGRADED
                    
            except Exception as e:
                results[check.name] = {
                    "status": HealthStatus.UNHEALTHY.value,
                    "message": f"Health check failed: {str(e)}",
                    "error": str(e)
                }
                overall_status = HealthStatus.UNHEALTHY
        
        return {
            "status": overall_status.value,
            "checks": results,
            "timestamp": datetime.utcnow().isoformat()
        }

# 4. í—¬ìŠ¤ ì²´í¬ API ì—”ë“œí¬ì¸íŠ¸
# backend/nadle_backend/routers/health.py
from fastapi import APIRouter, Depends
from nadle_backend.health.checks import HealthCheckService
from nadle_backend.monitoring.metrics import metrics_collector

router = APIRouter(prefix="/health", tags=["health"])

@router.get("/")
async def health_check():
    """ê¸°ë³¸ í—¬ìŠ¤ ì²´í¬"""
    health_service = HealthCheckService()
    result = await health_service.run_all_checks()
    
    # ë©”íŠ¸ë¦­ ìˆ˜ì§‘
    metrics_collector.counter("health_check_total", tags={"status": result["status"]})
    
    return result

@router.get("/metrics")
async def get_metrics():
    """ë©”íŠ¸ë¦­ ì¡°íšŒ"""
    return {
        "counters": metrics_collector.counters,
        "gauges": metrics_collector.gauges,
        "histograms": {
            k: {
                "count": len(v),
                "min": min(v) if v else 0,
                "max": max(v) if v else 0,
                "avg": sum(v) / len(v) if v else 0
            } for k, v in metrics_collector.histograms.items()
        }
    }
```

## ğŸ“Š ë¦¬íŒ©í„°ë§ ìš°ì„ ìˆœìœ„ ë° ì‹¤í–‰ ê³„íš

### ğŸ”¥ 1ë‹¨ê³„: ì¦‰ì‹œ ì‹¤í–‰ (1-2ì£¼)

#### ë°±ì—”ë“œ ìš°ì„ ìˆœìœ„
1. **ë¡œê¹… ì‹œìŠ¤í…œ í‘œì¤€í™”** (2ì¼)
   - `print()` â†’ `logging` ì „í™˜
   - êµ¬ì¡°í™”ëœ ë¡œê¹… ì„¤ì •
   - ë¡œê·¸ ë ˆë²¨ ì ìš©

2. **ëŒ€í˜• íŒŒì¼ ë¶„ë¦¬** (3ì¼)
   - `models/core.py` â†’ ë„ë©”ì¸ë³„ ë¶„ë¦¬
   - `services/posts_service.py` â†’ ê¸°ëŠ¥ë³„ ë¶„ë¦¬
   - `config.py` â†’ í™˜ê²½ë³„ ë¶„ë¦¬

3. **ìˆœí™˜ ì°¸ì¡° í•´ê²°** (2ì¼)
   - ì„œë¹„ìŠ¤ ê°„ import ì œê±°
   - ê³µí†µ ìœ í‹¸ë¦¬í‹° ëª¨ë“ˆ ìƒì„±
   - ì˜ì¡´ì„± ì£¼ì… íŒ¨í„´ ì ìš©

#### í”„ëŸ°íŠ¸ì—”ë“œ ìš°ì„ ìˆœìœ„
1. **íƒ€ì… ì‹œìŠ¤í…œ ë‹¨ìˆœí™”** (3ì¼)
   - ë„ë©”ì¸ë³„ íƒ€ì… íŒŒì¼ ë¶„ë¦¬
   - íƒ€ì… ë³€í™˜ ìœ í‹¸ë¦¬í‹° êµ¬í˜„
   - ë°±ì—”ë“œ í˜¸í™˜ì„± ë ˆì´ì–´ ìƒì„±

2. **Context êµ¬ì¡° ìµœì í™”** (2ì¼)
   - í†µí•© AppContext êµ¬í˜„
   - íŠ¹í™”ëœ ì»¤ìŠ¤í…€ í›… ìƒì„±
   - Provider ì¤‘ì²© ì œê±°

### âš¡ 2ë‹¨ê³„: ì¤‘ê¸° ì‹¤í–‰ (2-4ì£¼)

#### ê³µí†µ ìš°ì„ ìˆœìœ„
1. **ì„±ëŠ¥ ìµœì í™”** (1ì£¼)
   - ë°±ì—”ë“œ: ìºì‹± ì‹œìŠ¤í…œ ë„ì…
   - í”„ëŸ°íŠ¸ì—”ë“œ: ê°€ìƒí™” ë¦¬ìŠ¤íŠ¸, ì´ë¯¸ì§€ ìµœì í™”

2. **API í´ë¼ì´ì–¸íŠ¸ ê°œì„ ** (1ì£¼)
   - ë‹¨ì¼ í´ë˜ìŠ¤ ë¶„í• 
   - ì„œë¹„ìŠ¤ë³„ í´ë¼ì´ì–¸íŠ¸ êµ¬í˜„
   - ì¸í„°ì…‰í„° íŒ¨í„´ ì ìš©

3. **í…ŒìŠ¤íŠ¸ ê°•í™”** (1ì£¼)
   - íŒ©í† ë¦¬ íŒ¨í„´ ë„ì…
   - í†µí•© í…ŒìŠ¤íŠ¸ í™•ëŒ€
   - E2E í…ŒìŠ¤íŠ¸ ì•ˆì •ì„± ê°œì„ 

### ğŸš€ 3ë‹¨ê³„: ì¥ê¸° ì‹¤í–‰ (1-2ê°œì›”)

1. **ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ** (2ì£¼)
   - APM ë„êµ¬ ë„ì…
   - ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹œìŠ¤í…œ
   - í—¬ìŠ¤ ì²´í¬ ìë™í™”

2. **ê³ ê¸‰ ê¸°ëŠ¥ êµ¬í˜„** (3ì£¼)
   - ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ (WebSocket)
   - ì˜¤í”„ë¼ì¸ ì§€ì› (Service Worker)
   - ì ‘ê·¼ì„± ê°œì„  (ARIA, í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´ì…˜)

3. **ë¬¸ì„œí™” ë° ê°€ì´ë“œ** (1ì£¼)
   - API ë¬¸ì„œ ìë™ ìƒì„±
   - ì•„í‚¤í…ì²˜ ê°€ì´ë“œ
   - ê°œë°œì ì˜¨ë³´ë”© ë¬¸ì„œ

## ğŸ¯ ì„±ê³µ ì§€í‘œ

### ì •ëŸ‰ì  ì§€í‘œ
- **ì½”ë“œ í’ˆì§ˆ**: ESLint/Pylint ì˜¤ë¥˜ 0ê°œ
- **í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€**: ë°±ì—”ë“œ 90%, í”„ëŸ°íŠ¸ì—”ë“œ 80%
- **ë¹Œë“œ ì‹œê°„**: 30% ë‹¨ì¶•
- **API ì‘ë‹µ ì‹œê°„**: í‰ê·  200ms ì´í•˜
- **ë²ˆë“¤ í¬ê¸°**: í”„ëŸ°íŠ¸ì—”ë“œ 1MB ì´í•˜

### ì •ì„±ì  ì§€í‘œ
- **ê°œë°œ ìƒì‚°ì„±**: ìƒˆ ê¸°ëŠ¥ ê°œë°œ ì‹œê°„ ë‹¨ì¶•
- **ìœ ì§€ë³´ìˆ˜ì„±**: ì½”ë“œ ì´í•´ë„ ë° ìˆ˜ì • ìš©ì´ì„± í–¥ìƒ
- **ì•ˆì •ì„±**: í”„ë¡œë•ì…˜ ë²„ê·¸ ë°œìƒë¥  ê°ì†Œ
- **íŒ€ ë§Œì¡±ë„**: ê°œë°œì ê²½í—˜ ê°œì„ 

## ğŸ“ ê²°ë¡ 

ì´ ë¦¬íŒ©í„°ë§ ê°€ì´ë“œëŠ” ì‹¤ì œ ì½”ë“œ ë¶„ì„ì„ ë°”íƒ•ìœ¼ë¡œ êµ¬ì²´ì ì¸ êµ¬í˜„ ë°©ë²•ì„ ì œì‹œí•©ë‹ˆë‹¤. **ì ì§„ì ì´ê³  ì•ˆì „í•œ ë¦¬íŒ©í„°ë§**ì„ í†µí•´ ì½”ë“œ í’ˆì§ˆê³¼ ê°œë°œ ìƒì‚°ì„±ì„ í¬ê²Œ í–¥ìƒì‹œí‚¬ ìˆ˜ ìˆì„ ê²ƒì…ë‹ˆë‹¤.

íŠ¹íˆ **1ë‹¨ê³„ ê¸´ê¸‰ ê°œì„ **ì„ ìš°ì„ ì ìœ¼ë¡œ ì§„í–‰í•˜ì—¬ ì¦‰ê°ì ì¸ íš¨ê³¼ë¥¼ í™•ì¸í•œ í›„, ë‹¨ê³„ì ìœ¼ë¡œ í™•ëŒ€í•˜ëŠ” ê²ƒì„ ì¶”ì²œí•©ë‹ˆë‹¤.

---

*ì´ ê°€ì´ë“œëŠ” 2025ë…„ 7ì›” 6ì¼ ì‹¤ì œ ì½”ë“œ ë¶„ì„ ê²°ê³¼ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì‘ì„±ë˜ì—ˆìœ¼ë©°, í”„ë¡œì íŠ¸ ìƒí™©ì— ë”°ë¼ ì¡°ì •ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.*