"""
Íµ¨Ï°∞ÌôîÎêú Î°úÍπÖ ÏãúÏä§ÌÖú

Sentry ÎåÄÏ≤¥Ïö© ÏûêÏ≤¥ Íµ¨Ï°∞ÌôîÎêú Î°úÍπÖ Î∞è ÏóêÎü¨ Ï∂îÏ†Å ÏãúÏä§ÌÖú
"""
import json
import logging
import sys
import traceback
from datetime import datetime
from typing import Dict, Any, Optional, List
from enum import Enum
from dataclasses import dataclass, asdict
from pathlib import Path

# Google Cloud Logging 
try:
    import google.cloud.logging
    from google.cloud import logging as gcp_logging
    GCP_LOGGING_AVAILABLE = True
except ImportError:
    GCP_LOGGING_AVAILABLE = False

# Discord ÏïåÎ¶ºÏö©
import asyncio
import aiohttp
from nadle_backend.config import settings


class LogLevel(Enum):
    """Î°úÍ∑∏ Î†àÎ≤® Ïó¥Í±∞Ìòï"""
    DEBUG = "DEBUG"
    INFO = "INFO"
    WARNING = "WARNING"
    ERROR = "ERROR"
    CRITICAL = "CRITICAL"


class ErrorType(Enum):
    """ÏóêÎü¨ Ïú†Ìòï Î∂ÑÎ•ò"""
    SYSTEM_ERROR = "system_error"
    BUSINESS_ERROR = "business_error"
    VALIDATION_ERROR = "validation_error"
    AUTHENTICATION_ERROR = "authentication_error"
    AUTHORIZATION_ERROR = "authorization_error"
    EXTERNAL_API_ERROR = "external_api_error"
    DATABASE_ERROR = "database_error"
    PERFORMANCE_ERROR = "performance_error"


@dataclass
class LogContext:
    """Î°úÍ∑∏ Ïª®ÌÖçÏä§Ìä∏ Ï†ïÎ≥¥"""
    user_id: Optional[str] = None
    session_id: Optional[str] = None
    request_id: Optional[str] = None
    endpoint: Optional[str] = None
    method: Optional[str] = None
    ip_address: Optional[str] = None
    user_agent: Optional[str] = None
    environment: Optional[str] = None


@dataclass
class ErrorInfo:
    """ÏóêÎü¨ Ï†ïÎ≥¥"""
    error_type: ErrorType
    message: str
    stack_trace: Optional[str] = None
    error_code: Optional[str] = None
    additional_data: Optional[Dict[str, Any]] = None


@dataclass
class PerformanceInfo:
    """ÏÑ±Îä• Ï†ïÎ≥¥"""
    duration: float
    operation: str
    endpoint: Optional[str] = None
    slow_query: bool = False
    memory_usage: Optional[int] = None


class StructuredLogger:
    """Íµ¨Ï°∞ÌôîÎêú Î°úÍ±∞ ÌÅ¥ÎûòÏä§"""
    
    def __init__(self, name: str = "nadle_backend"):
        self.name = name
        self.logger = logging.getLogger(name)
        self.gcp_client = None
        self.discord_webhook_url = getattr(settings, 'discord_webhook_url', None)
        
        # Î°úÍ±∞ ÏÑ§Ï†ï
        self._setup_logger()
        
        # Google Cloud Logging Ï¥àÍ∏∞Ìôî
        if GCP_LOGGING_AVAILABLE:
            self._setup_gcp_logging()
    
    def _setup_logger(self):
        """Î°úÍ±∞ Í∏∞Î≥∏ ÏÑ§Ï†ï"""
        self.logger.setLevel(logging.INFO)
        
        # Ìï∏Îì§Îü¨Í∞Ä Ïù¥ÎØ∏ ÏûàÏúºÎ©¥ Ï†úÍ±∞
        if self.logger.handlers:
            self.logger.handlers.clear()
        
        # ÏΩòÏÜî Ìï∏Îì§Îü¨ Ï∂îÍ∞Ä
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setLevel(logging.INFO)
        
        # JSON ÌòïÏãù Ìè¨Îß∑ÌÑ∞
        formatter = JsonFormatter()
        console_handler.setFormatter(formatter)
        
        self.logger.addHandler(console_handler)
        
        # ÌååÏùº Ìï∏Îì§Îü¨ Ï∂îÍ∞Ä
        log_dir = Path("logs")
        log_dir.mkdir(exist_ok=True)
        
        file_handler = logging.FileHandler(log_dir / "app.log")
        file_handler.setLevel(logging.INFO)
        file_handler.setFormatter(formatter)
        
        self.logger.addHandler(file_handler)
        
        # ÏóêÎü¨ Ï†ÑÏö© ÌååÏùº Ìï∏Îì§Îü¨
        error_handler = logging.FileHandler(log_dir / "errors.log")
        error_handler.setLevel(logging.ERROR)
        error_handler.setFormatter(formatter)
        
        self.logger.addHandler(error_handler)
    
    def _setup_gcp_logging(self):
        """Google Cloud Logging ÏÑ§Ï†ï"""
        try:
            self.gcp_client = gcp_logging.Client()
            self.gcp_client.setup_logging()
            self.logger.info("Google Cloud Logging initialized successfully")
        except Exception as e:
            self.logger.warning(f"Failed to initialize Google Cloud Logging: {e}")
    
    def log(
        self,
        level: LogLevel,
        message: str,
        context: Optional[LogContext] = None,
        error_info: Optional[ErrorInfo] = None,
        performance_info: Optional[PerformanceInfo] = None,
        additional_data: Optional[Dict[str, Any]] = None
    ):
        """Íµ¨Ï°∞ÌôîÎêú Î°úÍ∑∏ Í∏∞Î°ù"""
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": level.value,
            "message": message,
            "service": "nadle_backend",
            "version": "1.0.0"
        }
        
        if context:
            log_entry["context"] = asdict(context)
        
        if error_info:
            log_entry["error"] = asdict(error_info)
        
        if performance_info:
            log_entry["performance"] = asdict(performance_info)
        
        if additional_data:
            log_entry["additional_data"] = additional_data
        
        # Î°úÍ∑∏ Î†àÎ≤®Ïóê Îî∞Î•∏ Í∏∞Î°ù
        if level == LogLevel.DEBUG:
            self.logger.debug(json.dumps(log_entry, ensure_ascii=False))
        elif level == LogLevel.INFO:
            self.logger.info(json.dumps(log_entry, ensure_ascii=False))
        elif level == LogLevel.WARNING:
            self.logger.warning(json.dumps(log_entry, ensure_ascii=False))
        elif level == LogLevel.ERROR:
            self.logger.error(json.dumps(log_entry, ensure_ascii=False))
            # ÏóêÎü¨ Ïãú Discord ÏïåÎ¶º
            if self.discord_webhook_url:
                asyncio.create_task(self._send_discord_notification(log_entry))
        elif level == LogLevel.CRITICAL:
            self.logger.critical(json.dumps(log_entry, ensure_ascii=False))
            # ÏπòÎ™ÖÏ†Å ÏóêÎü¨ Ïãú Discord ÏïåÎ¶º
            if self.discord_webhook_url:
                asyncio.create_task(self._send_discord_notification(log_entry))
    
    def info(self, message: str, context: Optional[LogContext] = None, **kwargs):
        """INFO Î†àÎ≤® Î°úÍ∑∏"""
        self.log(LogLevel.INFO, message, context, additional_data=kwargs)
    
    def warning(self, message: str, context: Optional[LogContext] = None, **kwargs):
        """WARNING Î†àÎ≤® Î°úÍ∑∏"""
        self.log(LogLevel.WARNING, message, context, additional_data=kwargs)
    
    def error(
        self,
        message: str,
        error_type: ErrorType = ErrorType.SYSTEM_ERROR,
        exception: Optional[Exception] = None,
        context: Optional[LogContext] = None,
        **kwargs
    ):
        """ERROR Î†àÎ≤® Î°úÍ∑∏"""
        error_info = ErrorInfo(
            error_type=error_type,
            message=message,
            stack_trace=traceback.format_exc() if exception else None,
            additional_data=kwargs
        )
        
        self.log(LogLevel.ERROR, message, context, error_info=error_info)
    
    def critical(
        self,
        message: str,
        error_type: ErrorType = ErrorType.SYSTEM_ERROR,
        exception: Optional[Exception] = None,
        context: Optional[LogContext] = None,
        **kwargs
    ):
        """CRITICAL Î†àÎ≤® Î°úÍ∑∏"""
        error_info = ErrorInfo(
            error_type=error_type,
            message=message,
            stack_trace=traceback.format_exc() if exception else None,
            additional_data=kwargs
        )
        
        self.log(LogLevel.CRITICAL, message, context, error_info=error_info)
    
    def performance(
        self,
        operation: str,
        duration: float,
        endpoint: Optional[str] = None,
        context: Optional[LogContext] = None,
        **kwargs
    ):
        """ÏÑ±Îä• Î°úÍ∑∏"""
        performance_info = PerformanceInfo(
            duration=duration,
            operation=operation,
            endpoint=endpoint,
            slow_query=duration > 1.0,  # 1Ï¥à Ïù¥ÏÉÅÏù¥Î©¥ ÎäêÎ¶∞ ÏøºÎ¶¨
            **kwargs
        )
        
        level = LogLevel.WARNING if duration > 2.0 else LogLevel.INFO
        self.log(level, f"Performance: {operation}", context, performance_info=performance_info)
    
    async def _send_discord_notification(self, log_entry: Dict[str, Any]):
        """Discord ÏïåÎ¶º Ï†ÑÏÜ°"""
        if not self.discord_webhook_url:
            return
        
        try:
            # Discord ÏûÑÎ≤†Îìú Î©îÏãúÏßÄ ÏÉùÏÑ±
            embed = {
                "title": "üö® Backend Error Alert",
                "description": log_entry["message"],
                "color": 0xFF0000,  # Îπ®Í∞ÑÏÉâ
                "timestamp": log_entry["timestamp"],
                "fields": []
            }
            
            # ÏóêÎü¨ Ï†ïÎ≥¥ Ï∂îÍ∞Ä
            if "error" in log_entry:
                error_info = log_entry["error"]
                embed["fields"].append({
                    "name": "Error Type",
                    "value": error_info.get("error_type", "Unknown"),
                    "inline": True
                })
                
                if error_info.get("stack_trace"):
                    # Ïä§ÌÉù Ìä∏Î†àÏù¥Ïä§Îäî Í∏∏Ïñ¥Ïßà Ïàò ÏûàÏúºÎØÄÎ°ú Ï∂ïÏïΩ
                    stack_trace = error_info["stack_trace"][:1000] + "..." if len(error_info["stack_trace"]) > 1000 else error_info["stack_trace"]
                    embed["fields"].append({
                        "name": "Stack Trace",
                        "value": f"```{stack_trace}```",
                        "inline": False
                    })
            
            # Ïª®ÌÖçÏä§Ìä∏ Ï†ïÎ≥¥ Ï∂îÍ∞Ä
            if "context" in log_entry:
                context_info = log_entry["context"]
                if context_info.get("endpoint"):
                    embed["fields"].append({
                        "name": "Endpoint",
                        "value": f"{context_info.get('method', 'GET')} {context_info['endpoint']}",
                        "inline": True
                    })
                
                if context_info.get("user_id"):
                    embed["fields"].append({
                        "name": "User ID",
                        "value": context_info["user_id"],
                        "inline": True
                    })
            
            # ÌôòÍ≤Ω Ï†ïÎ≥¥ Ï∂îÍ∞Ä
            embed["fields"].append({
                "name": "Environment",
                "value": settings.environment,
                "inline": True
            })
            
            # Discord ÏõπÌõÖÏúºÎ°ú Ï†ÑÏÜ°
            payload = {
                "embeds": [embed]
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    self.discord_webhook_url,
                    json=payload,
                    timeout=aiohttp.ClientTimeout(total=10)
                ) as response:
                    if response.status == 204:
                        print("Discord notification sent successfully")
                    else:
                        print(f"Failed to send Discord notification: {response.status}")
        
        except Exception as e:
            # Discord ÏïåÎ¶º Ïã§Ìå®Ìï¥ÎèÑ Î©îÏù∏ Î°úÍπÖÏóêÎäî ÏòÅÌñ• ÏóÜÏùå
            print(f"Failed to send Discord notification: {e}")


class JsonFormatter(logging.Formatter):
    """JSON ÌòïÏãù Î°úÍ∑∏ Ìè¨Îß∑ÌÑ∞"""
    
    def format(self, record: logging.LogRecord) -> str:
        """Î°úÍ∑∏ Î†àÏΩîÎìúÎ•º JSON ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò"""
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": record.levelname,
            "message": record.getMessage(),
            "logger": record.name,
            "module": record.module,
            "function": record.funcName,
            "line": record.lineno
        }
        
        # ÏòàÏô∏ Ï†ïÎ≥¥ Ï∂îÍ∞Ä
        if record.exc_info:
            log_entry["exception"] = self.formatException(record.exc_info)
        
        # Ï∂îÍ∞Ä ÏÜçÏÑ± Ï∂îÍ∞Ä
        for key, value in record.__dict__.items():
            if key not in ['name', 'msg', 'args', 'levelname', 'levelno', 'pathname', 'filename',
                          'module', 'lineno', 'funcName', 'created', 'msecs', 'relativeCreated',
                          'thread', 'threadName', 'processName', 'process', 'getMessage',
                          'exc_info', 'exc_text', 'stack_info']:
                log_entry[key] = value
        
        return json.dumps(log_entry, ensure_ascii=False, default=str)


# Ï†ÑÏó≠ Î°úÍ±∞ Ïù∏Ïä§ÌÑ¥Ïä§
structured_logger = StructuredLogger()


# Ìé∏Ïùò Ìï®ÏàòÎì§
def log_info(message: str, context: Optional[LogContext] = None, **kwargs):
    """INFO Î°úÍ∑∏ Í∏∞Î°ù"""
    structured_logger.info(message, context, **kwargs)


def log_warning(message: str, context: Optional[LogContext] = None, **kwargs):
    """WARNING Î°úÍ∑∏ Í∏∞Î°ù"""
    structured_logger.warning(message, context, **kwargs)


def log_error(
    message: str,
    error_type: ErrorType = ErrorType.SYSTEM_ERROR,
    exception: Optional[Exception] = None,
    context: Optional[LogContext] = None,
    **kwargs
):
    """ERROR Î°úÍ∑∏ Í∏∞Î°ù"""
    structured_logger.error(message, error_type, exception, context, **kwargs)


def log_performance(
    operation: str,
    duration: float,
    endpoint: Optional[str] = None,
    context: Optional[LogContext] = None,
    **kwargs
):
    """ÏÑ±Îä• Î°úÍ∑∏ Í∏∞Î°ù"""
    structured_logger.performance(operation, duration, endpoint, context, **kwargs)


def get_request_context(request) -> LogContext:
    """FastAPI Request Í∞ùÏ≤¥Î°úÎ∂ÄÌÑ∞ LogContext ÏÉùÏÑ±"""
    return LogContext(
        request_id=request.headers.get("X-Request-ID"),
        endpoint=str(request.url.path),
        method=request.method,
        ip_address=request.client.host if request.client else None,
        user_agent=request.headers.get("User-Agent"),
        environment=settings.environment
    )