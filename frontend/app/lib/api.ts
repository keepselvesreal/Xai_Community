import type {
  User,
  AuthToken,
  LoginRequest,
  RegisterRequest,
  Post,
  CreatePostRequest,
  Comment,
  CreateCommentRequest,
  CommentListResponse,
  Reaction,
  ReactionType,
  ApiResponse,
  PaginatedResponse,
  PostFilters,
  ApiTestRequest,
  ApiTestResponse,
  UserActivityResponse,
  EmailVerificationRequest,
  EmailVerificationResponse,
  EmailVerificationCodeRequest,
  EmailVerificationCodeResponse,
} from "~/types";
import { validateJWTFormat, decodeJWTPayload, isTokenExpired } from './jwt-utils';
import { 
  STORAGE_KEYS, 
  SESSION_CONFIG, 
  SESSION_EXPIRY_REASONS,
  SESSION_MESSAGES
} from './constants';

const API_BASE_URL = import.meta.env.VITE_API_URL || 'https://xai-community-backend-798170408536.asia-northeast3.run.app';

// ‚úÖ ÌôòÍ≤ΩÎ≥ÄÏàò ÎîîÎ≤ÑÍπÖ (VERCEL_ENV Í∞úÌñâÎ¨∏Ïûê Î¨∏Ï†ú Ìï¥Í≤∞ ÌõÑ)
console.log('üîç API_BASE_URL ÏÑ§Ï†ïÍ∞í:', API_BASE_URL);
console.log('üîç VITE_API_URL ÌôòÍ≤ΩÎ≥ÄÏàò:', import.meta.env.VITE_API_URL);
console.log('üîç Environment Mode:', import.meta.env.MODE);
console.log('‚úÖ NODE_ENV:', import.meta.env.NODE_ENV);
console.log('‚úÖ PROD:', import.meta.env.PROD);
console.log('‚úÖ DEV:', import.meta.env.DEV);
console.log('‚úÖ VERCEL_ENV:', import.meta.env.VERCEL_ENV);
console.log('‚úÖ Process NODE_ENV:', typeof process !== 'undefined' ? process.env.NODE_ENV : 'undefined');
console.log('‚úÖ Process VERCEL_ENV:', typeof process !== 'undefined' ? process.env.VERCEL_ENV : 'undefined');

class ApiClient {
  private baseURL: string;
  private token: string | null = null;
  private refreshToken: string | null = null;
  private isRefreshing: boolean = false;
  private refreshPromise: Promise<boolean> | null = null;
  private tokenCheckInterval: number | null = null;

  constructor(baseURL: string = API_BASE_URL) {
    this.baseURL = baseURL;
    this.loadTokens();
  }

  private loadTokens(): void {
    if (typeof window !== 'undefined') {
      let token = localStorage.getItem(STORAGE_KEYS.AUTH_TOKEN);
      let refreshToken = localStorage.getItem(STORAGE_KEYS.REFRESH_TOKEN);
      
      // JSON.stringifyÎ°ú Ï†ÄÏû•Îêú Í≤ΩÏö∞ ÌååÏã±
      if (token && (token.startsWith('"') && token.endsWith('"'))) {
        try {
          token = JSON.parse(token);
          if (token) {
            localStorage.setItem(STORAGE_KEYS.AUTH_TOKEN, token); // Ï†ïÎ¶¨Îêú ÌÜ†ÌÅ∞ Ïû¨Ï†ÄÏû•
            console.log('ApiClient: Cleaned JSON stringified token');
          }
        } catch (e) {
          console.error('ApiClient: Failed to parse token:', e);
        }
      }
      
      // Bearer Ï†ëÎëêÏÇ¨Í∞Ä ÏûòÎ™ª Ï†ÄÏû•Îêú Í≤ΩÏö∞ Ï†úÍ±∞
      if (token && token.startsWith('Bearer ')) {
        token = token.substring(7);
        localStorage.setItem(STORAGE_KEYS.AUTH_TOKEN, token);
        console.log('ApiClient: Cleaned Bearer prefix from stored token');
      }
      
      this.token = token;
      this.refreshToken = refreshToken;
      console.log('ApiClient: Tokens loaded from localStorage:', 
        this.token ? `access: ${this.token.substring(0, 10)}...` : 'access: null',
        this.refreshToken ? `refresh: ${this.refreshToken.substring(0, 10)}...` : 'refresh: null'
      );
      
      // ÏÑ∏ÏÖò ÎßåÎ£å Ï≤¥ÌÅ¨
      if (this.token && this.refreshToken) {
        if (this.isSessionExpired()) {
          console.log('ApiClient: Session expired, forcing logout');
          this.handleSessionExpiry(this.getSessionExpiryReason());
          return;
        }
        
        // ÌÜ†ÌÅ∞Ïù¥ ÏûàÍ≥† ÏÑ∏ÏÖòÏù¥ Ïú†Ìö®ÌïòÎ©¥ ÏûêÎèô Í∞±Ïã† ÌÉÄÏù¥Î®∏ ÏãúÏûë
        this.startTokenRefreshTimer();
      }
    }
  }

  private saveTokens(accessToken: string, refreshToken?: string): void {
    // Bearer Ï†ëÎëêÏÇ¨ Ï†úÍ±∞ (ÌÜ†ÌÅ∞Îßå Ï†ÄÏû•)
    const cleanToken = accessToken.startsWith('Bearer ') ? accessToken.substring(7) : accessToken;
    
    this.token = cleanToken;
    if (refreshToken) {
      this.refreshToken = refreshToken;
    }
    
    if (typeof window !== 'undefined') {
      localStorage.setItem(STORAGE_KEYS.AUTH_TOKEN, cleanToken);
      if (refreshToken) {
        localStorage.setItem(STORAGE_KEYS.REFRESH_TOKEN, refreshToken);
      }
      console.log('ApiClient: Tokens saved to localStorage:', 
        cleanToken ? `access: ${cleanToken.substring(0, 10)}...` : 'access: null',
        refreshToken ? `refresh: ${refreshToken.substring(0, 10)}...` : 'refresh: unchanged'
      );
    }
  }

  // ÏÑ∏ÏÖò Í¥ÄÎ¶¨ Î©îÏÑúÎìúÎì§ (ÌïòÏù¥Î∏åÎ¶¨Îìú Î∞©Ïãù)
  private saveLoginTime(): void {
    if (typeof window !== 'undefined') {
      const loginTime = new Date().toISOString();
      localStorage.setItem(STORAGE_KEYS.LOGIN_TIME, loginTime);
      localStorage.setItem(STORAGE_KEYS.REFRESH_COUNT, '0');
      console.log('ApiClient: Login time saved:', loginTime);
    }
  }

  private getLoginTime(): Date | null {
    if (typeof window === 'undefined') return null;
    
    const loginTimeStr = localStorage.getItem(STORAGE_KEYS.LOGIN_TIME);
    return loginTimeStr ? new Date(loginTimeStr) : null;
  }

  private getRefreshCount(): number {
    if (typeof window === 'undefined') return 0;
    
    const count = localStorage.getItem(STORAGE_KEYS.REFRESH_COUNT);
    return count ? parseInt(count, 10) : 0;
  }

  private incrementRefreshCount(): void {
    if (typeof window !== 'undefined') {
      const currentCount = this.getRefreshCount();
      const newCount = currentCount + 1;
      localStorage.setItem(STORAGE_KEYS.REFRESH_COUNT, newCount.toString());
      console.log('ApiClient: Refresh count incremented to:', newCount);
    }
  }

  private isSessionExpired(): boolean {
    const loginTime = this.getLoginTime();
    const refreshCount = this.getRefreshCount();
    
    if (!loginTime) return false;
    
    // Ï°∞Í±¥ 1: Ï†àÎåÄ ÏãúÍ∞Ñ Ï†úÌïú (8ÏãúÍ∞Ñ Í≤ΩÍ≥º)
    const elapsed = (Date.now() - loginTime.getTime()) / (1000 * 60 * 60);
    if (elapsed > SESSION_CONFIG.MAX_SESSION_HOURS) {
      console.log('ApiClient: Session expired due to time limit:', elapsed, 'hours');
      return true;
    }
    
    // Ï°∞Í±¥ 2: Í∞±Ïã† ÌöüÏàò Ï†úÌïú (16Ìöå Ï¥àÍ≥º)
    if (refreshCount >= SESSION_CONFIG.MAX_REFRESH_COUNT) {
      console.log('ApiClient: Session expired due to refresh limit:', refreshCount);
      return true;
    }
    
    return false;
  }

  private getSessionExpiryReason(): string {
    const loginTime = this.getLoginTime();
    const refreshCount = this.getRefreshCount();
    
    if (!loginTime) return SESSION_EXPIRY_REASONS.TOKEN_INVALID;
    
    const elapsed = (Date.now() - loginTime.getTime()) / (1000 * 60 * 60);
    if (elapsed > SESSION_CONFIG.MAX_SESSION_HOURS) {
      return SESSION_EXPIRY_REASONS.TIME_LIMIT;
    }
    
    if (refreshCount >= SESSION_CONFIG.MAX_REFRESH_COUNT) {
      return SESSION_EXPIRY_REASONS.REFRESH_LIMIT;
    }
    
    return SESSION_EXPIRY_REASONS.TOKEN_INVALID;
  }

  private shouldShowSessionWarning(): boolean {
    const loginTime = this.getLoginTime();
    if (!loginTime) return false;
    
    const elapsed = (Date.now() - loginTime.getTime()) / (1000 * 60);
    const warningThreshold = (SESSION_CONFIG.MAX_SESSION_HOURS * 60) - SESSION_CONFIG.WARNING_BEFORE_LOGOUT_MINUTES;
    
    return elapsed > warningThreshold;
  }

  private handleSessionExpiry(reason: string): void {
    console.log('ApiClient: Handling session expiry, reason:', reason);
    
    // ÌÜ†ÌÅ∞ Î∞è ÏÑ∏ÏÖò Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨
    this.removeTokens();
    
    // ÏÑ∏ÏÖò ÎßåÎ£å Ïù¥Î≤§Ìä∏ Î∞úÏÉù (AuthContextÏóêÏÑú Ï≤òÎ¶¨)
    if (typeof window !== 'undefined') {
      window.dispatchEvent(new CustomEvent('sessionExpired', { 
        detail: { reason } 
      }));
    }
  }

  private removeTokens(): void {
    this.token = null;
    this.refreshToken = null;
    if (typeof window !== 'undefined') {
      localStorage.removeItem(STORAGE_KEYS.AUTH_TOKEN);
      localStorage.removeItem(STORAGE_KEYS.REFRESH_TOKEN);
      localStorage.removeItem(STORAGE_KEYS.LOGIN_TIME);
      localStorage.removeItem(STORAGE_KEYS.REFRESH_COUNT);
    }
    this.stopTokenRefreshTimer();
  }

  private startTokenRefreshTimer(): void {
    if (typeof window === 'undefined') return;
    
    // Í∏∞Ï°¥ ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
    this.stopTokenRefreshTimer();
    
    // ÏÑ§Ï†ïÎêú Ï£ºÍ∏∞ÎßàÎã§ ÌÜ†ÌÅ∞ Î∞è ÏÑ∏ÏÖò ÏÉÅÌÉú ÌôïÏù∏
    const intervalMinutes = SESSION_CONFIG.SESSION_CHECK_INTERVAL_MINUTES;
    this.tokenCheckInterval = window.setInterval(() => {
      this.checkAndRefreshToken();
    }, intervalMinutes * 60 * 1000);
  }

  private stopTokenRefreshTimer(): void {
    if (this.tokenCheckInterval) {
      clearInterval(this.tokenCheckInterval);
      this.tokenCheckInterval = null;
    }
  }

  private async checkAndRefreshToken(): Promise<void> {
    if (!this.token || !this.refreshToken) {
      return;
    }

    try {
      // 1. Î®ºÏ†Ä ÏÑ∏ÏÖò ÎßåÎ£å Ï≤¥ÌÅ¨
      if (this.isSessionExpired()) {
        console.log('ApiClient: Session expired during check');
        this.handleSessionExpiry(this.getSessionExpiryReason());
        return;
      }

      // 2. ÏÑ∏ÏÖò Í≤ΩÍ≥† Ï≤¥ÌÅ¨
      if (this.shouldShowSessionWarning()) {
        console.log('ApiClient: Session warning should be shown');
        if (typeof window !== 'undefined') {
          window.dispatchEvent(new CustomEvent('sessionWarning'));
        }
      }

      // 3. ÌÜ†ÌÅ∞ ÎßåÎ£å Ï≤¥ÌÅ¨ Î∞è Í∞±Ïã†
      const thresholdMinutes = SESSION_CONFIG.TOKEN_REFRESH_THRESHOLD_MINUTES;
      if (this.isTokenExpired(this.token) || this.isTokenExpiringSoon(this.token, thresholdMinutes * 60)) {
        console.log('ApiClient: Token is expired or expiring soon, refreshing...');
        await this.refreshAccessToken();
      }
    } catch (error) {
      console.error('ApiClient: Error checking token expiration:', error);
    }
  }

  private isTokenExpiringSoon(token: string, secondsBeforeExpiry: number): boolean {
    try {
      const payload = this.decodeJWTPayload(token);
      const now = Math.floor(Date.now() / 1000);
      const expiresAt = payload.exp;
      
      // ÌòÑÏû¨ ÏãúÍ∞Ñ + secondsBeforeExpiryÍ∞Ä ÎßåÎ£å ÏãúÍ∞ÑÎ≥¥Îã§ ÌÅ¨Í±∞ÎÇò Í∞ôÏúºÎ©¥ Í≥ß ÎßåÎ£åÎê®
      return (now + secondsBeforeExpiry) >= expiresAt;
    } catch (error) {
      console.error('ApiClient: Error checking token expiration:', error);
      return true; // ÌååÏã± Ïã§Ìå® Ïãú ÏïàÏ†ÑÌïòÍ≤å ÎßåÎ£åÎêú Í≤ÉÏúºÎ°ú Ï≤òÎ¶¨
    }
  }

  private getHeaders(): Record<string, string> {
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
    };

    if (this.token) {
      // ÌÜ†ÌÅ∞ÏóêÏÑú Bearer Ï†ëÎëêÏÇ¨ Ï†úÍ±∞ ÌõÑ Îã§Ïãú Ï∂îÍ∞Ä (Ï†ïÍ∑úÌôî)
      const cleanToken = this.token.replace(/^Bearer\s+/i, '');
      headers['Authorization'] = `Bearer ${cleanToken}`;
      
      // ÎîîÎ≤ÑÍπÖÏö© Î°úÍ∑∏
      console.log('ApiClient: Setting Authorization header with token:', `Bearer ${cleanToken.substring(0, 10)}...`);
    }

    return headers;
  }

  private async refreshAccessToken(): Promise<boolean> {
    if (!this.refreshToken) {
      console.log('ApiClient: No refresh token available');
      return false;
    }

    if (this.isRefreshing) {
      // Ïù¥ÎØ∏ ÌÜ†ÌÅ∞ Í∞±Ïã† Ï§ëÏù¥Î©¥ Í∏∞Ï°¥ ÌîÑÎ°úÎØ∏Ïä§Î•º Í∏∞Îã§Î¶º
      return this.refreshPromise || Promise.resolve(false);
    }

    this.isRefreshing = true;
    this.refreshPromise = this.performTokenRefresh();
    
    const result = await this.refreshPromise;
    this.isRefreshing = false;
    this.refreshPromise = null;
    
    return result;
  }

  private async performTokenRefresh(): Promise<boolean> {
    try {
      console.log('ApiClient: Attempting to refresh access token...');
      
      // Í∞±Ïã† Ï†Ñ ÏÑ∏ÏÖò ÎßåÎ£å Ï≤¥ÌÅ¨
      if (this.isSessionExpired()) {
        console.log('ApiClient: Session expired, cannot refresh token');
        this.handleSessionExpiry(this.getSessionExpiryReason());
        return false;
      }
      
      const response = await fetch(`${this.baseURL}/api/auth/refresh`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ refresh_token: this.refreshToken }),
      });

      if (!response.ok) {
        console.error('ApiClient: Token refresh failed:', response.status, response.statusText);
        // Î¶¨ÌîÑÎ†àÏãú ÌÜ†ÌÅ∞Ïù¥ ÎßåÎ£åÎêòÏóàÍ±∞ÎÇò Î¨¥Ìö®Ìï® - Î°úÍ∑∏ÏïÑÏõÉ Ï≤òÎ¶¨
        this.handleSessionExpiry(SESSION_EXPIRY_REASONS.TOKEN_INVALID);
        return false;
      }

      const data = await response.json();
      console.log('ApiClient: Token refresh successful');
      
      // Í∞±Ïã† ÌöüÏàò Ï¶ùÍ∞Ä
      this.incrementRefreshCount();
      
      // ÏÉàÎ°úÏö¥ access token Ï†ÄÏû• (refresh tokenÏùÄ Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ)
      this.saveTokens(data.access_token);
      
      // Í∞±Ïã† ÌõÑ ÏÑ∏ÏÖò ÎßåÎ£å Ïû¨Ï≤¥ÌÅ¨ (Í∞±Ïã† ÌöüÏàò Ï†úÌïú)
      if (this.isSessionExpired()) {
        console.log('ApiClient: Session expired after refresh');
        this.handleSessionExpiry(this.getSessionExpiryReason());
        return false;
      }
      
      // ÌÜ†ÌÅ∞ Í∞±Ïã† ÌõÑ ÌÉÄÏù¥Î®∏ Ïû¨ÏãúÏûë
      this.startTokenRefreshTimer();
      
      return true;
    } catch (error) {
      console.error('ApiClient: Token refresh error:', error);
      this.handleSessionExpiry(SESSION_EXPIRY_REASONS.TOKEN_INVALID);
      return false;
    }
  }

  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<ApiResponse<T>> {
    return this.makeRequestWithRetry<T>(endpoint, options, false);
  }

  private async makeRequestWithRetry<T>(
    endpoint: string,
    options: RequestInit = {},
    isRetry: boolean = false
  ): Promise<ApiResponse<T>> {
    const url = `${this.baseURL}${endpoint}`;
    console.log('üîç ÏöîÏ≤≠ URL Íµ¨ÏÑ±:', { baseURL: this.baseURL, endpoint, finalURL: url });
    
    // ÌÜ†ÌÅ∞Ïù¥ ÏóÜÍ≥† refresh tokenÏù¥ ÏûàÎã§Î©¥ Î®ºÏ†Ä ÌÜ†ÌÅ∞ Í∞±Ïã† ÏãúÎèÑ
    if (!this.token && this.refreshToken && !isRetry) {
      console.log('ApiClient: No access token but refresh token exists, attempting refresh...');
      const refreshSuccess = await this.refreshAccessToken();
      if (!refreshSuccess) {
        console.log('ApiClient: Token refresh failed before request');
        // SSR ÌôòÍ≤ΩÏù¥Í±∞ÎÇò Í≥µÍ∞ú APIÏù∏ Í≤ΩÏö∞ ÌÜ†ÌÅ∞ ÏóÜÏù¥ Í≥ÑÏÜç ÏßÑÌñâ
        if (typeof window === 'undefined') {
          console.log('ApiClient: SSR environment - proceeding without token');
        } else {
          this.notifyTokenExpired();
        }
      }
    }
    
    const config: RequestInit = {
      headers: this.getHeaders(),
      ...options,
    };

    try {
      console.log('ApiClient: Making request to:', url, isRetry ? '(retry)' : '');
      const response = await fetch(url, config);
      console.log('ApiClient: Response received:', response.status, response.statusText);
      
      // 401 Unauthorized Ï≤òÎ¶¨ - ÌÜ†ÌÅ∞ Í∞±Ïã† ÏãúÎèÑ
      if (response.status === 401 && !isRetry && this.refreshToken) {
        console.log('ApiClient: Received 401, attempting token refresh...');
        const refreshSuccess = await this.refreshAccessToken();
        
        if (refreshSuccess) {
          console.log('ApiClient: Token refreshed successfully, retrying request...');
          // ÌÜ†ÌÅ∞ Í∞±Ïã† ÏÑ±Í≥µ Ïãú ÏöîÏ≤≠ Ïû¨ÏãúÎèÑ
          return this.makeRequestWithRetry<T>(endpoint, options, true);
        } else {
          console.log('ApiClient: Token refresh failed, user needs to login again');
          // ÌÜ†ÌÅ∞ Í∞±Ïã† Ïã§Ìå® Ïãú Î°úÍ∑∏ÏïÑÏõÉ Ïù¥Î≤§Ìä∏ Î∞úÏÉù
          this.notifyTokenExpired();
        }
      }
      
      // Îπà ÏùëÎãµ Ï≤òÎ¶¨
      let data;
      const contentType = response.headers.get('content-type');
      if (contentType && contentType.includes('application/json')) {
        const text = await response.text();
        if (text.trim()) {
          data = JSON.parse(text);
        } else {
          // Îπà JSON ÏùëÎãµ Ï≤òÎ¶¨
          data = { success: true };
        }
      } else {
        // JSONÏù¥ ÏïÑÎãå ÏùëÎãµ
        data = { success: true };
      }
      console.log('ApiClient: Response data:', data);

      if (!response.ok) {
        // ÏÉÅÏÑ∏Ìïú Ïò§Î•ò Ï†ïÎ≥¥ Î°úÍ∑∏
        console.error('API Error Details:', {
          url,
          status: response.status,
          statusText: response.statusText,
          data,
          requestBody: config.body
        });
        
        // FastAPI validation errors Ï≤òÎ¶¨
        if (response.status === 422 && data.detail) {
          const errorMessages = Array.isArray(data.detail) 
            ? data.detail.map((err: any) => `${err.loc?.join('.')}: ${err.msg}`).join(', ')
            : data.detail;
          throw new Error(`Validation Error: ${errorMessages}`);
        }
        
        throw new Error(data.message || data.detail || `HTTP error! status: ${response.status}`);
      }

      return {
        success: true,
        data,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      console.error('API request failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString(),
      };
    }
  }

  private notifyTokenExpired(): void {
    // ÌÜ†ÌÅ∞ ÎßåÎ£å Ïù¥Î≤§Ìä∏Î•º Î∞úÏÉùÏãúÏºú AuthContextÍ∞Ä Î°úÍ∑∏ÏïÑÏõÉ Ï≤òÎ¶¨ÌïòÎèÑÎ°ù Ìï®
    if (typeof window !== 'undefined') {
      window.dispatchEvent(new CustomEvent('tokenExpired'));
    }
  }

  // Ïù∏Ï¶ù Í¥ÄÎ†® API
  async login(credentials: LoginRequest): Promise<ApiResponse<AuthToken>> {
    // OAuth2PasswordRequestForm expects form-data with username/password fields
    const formData = new FormData();
    formData.append('username', credentials.email); // Backend expects 'username' field with email value
    formData.append('password', credentials.password);

    const url = `${this.baseURL}/api/auth/login`;
    
    try {
      const response = await fetch(url, {
        method: 'POST',
        body: formData, // Send as form-data, not JSON
      });
      
      const data = await response.json();

      if (!response.ok) {
        console.error('Login API Error Details:', {
          url,
          status: response.status,
          statusText: response.statusText,
          data
        });
        
        if (response.status === 422 && data.detail) {
          const errorMessages = Array.isArray(data.detail) 
            ? data.detail.map((err: any) => `${err.loc?.join('.')}: ${err.msg}`).join(', ')
            : data.detail;
          throw new Error(`Validation Error: ${errorMessages}`);
        }
        
        throw new Error(data.message || data.detail || `HTTP error! status: ${response.status}`);
      }

      this.saveTokens(data.access_token, data.refresh_token);
      
      // Î°úÍ∑∏Ïù∏ ÏãúÍ∞Ñ Ï†ÄÏû• (ÏÑ∏ÏÖò Í¥ÄÎ¶¨Ïö©)
      this.saveLoginTime();
      
      // Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ Ïãú ÌÜ†ÌÅ∞ ÏûêÎèô Í∞±Ïã† ÌÉÄÏù¥Î®∏ ÏãúÏûë
      this.startTokenRefreshTimer();
      
      return {
        success: true,
        data,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      console.error('Login API request failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString(),
      };
    }
  }

  async register(userData: RegisterRequest): Promise<ApiResponse<User>> {
    return this.request<User>('/api/auth/register', {
      method: 'POST',
      body: JSON.stringify(userData),
    });
  }

  async getCurrentUser(): Promise<ApiResponse<User>> {
    console.log('ApiClient: getCurrentUser called');
    const result = await this.request<User>('/api/auth/profile');
    console.log('ApiClient: getCurrentUser result:', result);
    return result;
  }

  // ÏÇ¨Ïö©Ïûê ÌôúÎèô Ï°∞Ìöå API
  async getUserActivity(page: number = 1, limit: number = 10): Promise<UserActivityResponse> {
    console.log('ApiClient: getUserActivity called with page:', page, 'limit:', limit);
    
    const queryParams = new URLSearchParams();
    queryParams.append('page', page.toString());
    queryParams.append('limit', limit.toString());
    
    const result = await this.request<UserActivityResponse>(`/api/users/me/activity?${queryParams.toString()}`, {
      method: 'GET',
    });
    
    if (!result.success) {
      throw new Error(result.error || 'Failed to fetch user activity');
    }
    
    console.log('ApiClient: getUserActivity result:', result.data);
    return result.data!;
  }

  logout(): void {
    console.log('ApiClient: Logout called');
    this.removeTokens();
    console.log('ApiClient: Tokens removed');
  }

  // Ïù∏Ï¶ù ÏÉÅÌÉú ÌôïÏù∏
  isAuthenticated(): boolean {
    return !!this.token && !this.isTokenExpired(this.token);
  }

  // ÌÖåÏä§Ìä∏Î•º ÏúÑÌïú public Î©îÏÑúÎìúÎì§ (ÏõêÎûòÎäî privateÏù¥ÏßÄÎßå ÌÖåÏä§Ìä∏ Ï†ëÍ∑ºÏùÑ ÏúÑÌï¥ publicÏúºÎ°ú ÎÖ∏Ï∂ú)
  public saveTokenPublic(token: string, refreshToken?: string): void {
    return this.saveTokens(token, refreshToken);
  }

  public getHeadersPublic(): Record<string, string> {
    return this.getHeaders();
  }

  // ÏÑ∏ÏÖò ÏÉÅÌÉú ÌôïÏù∏ÏùÑ ÏúÑÌïú public Î©îÏÑúÎìúÎì§
  public getSessionInfo() {
    const loginTime = this.getLoginTime();
    const refreshCount = this.getRefreshCount();
    const isExpired = this.isSessionExpired();
    const showWarning = this.shouldShowSessionWarning();
    
    let timeRemaining = 0;
    if (loginTime) {
      const elapsed = (Date.now() - loginTime.getTime()) / (1000 * 60 * 60);
      timeRemaining = Math.max(0, SESSION_CONFIG.MAX_SESSION_HOURS - elapsed);
    }
    
    return {
      loginTime,
      refreshCount,
      maxRefreshCount: SESSION_CONFIG.MAX_REFRESH_COUNT,
      isExpired,
      showWarning,
      timeRemaining: Math.round(timeRemaining * 100) / 100, // ÏÜåÏàòÏ†ê 2ÏûêÎ¶¨
      maxSessionHours: SESSION_CONFIG.MAX_SESSION_HOURS
    };
  }

  public extendSession(): boolean {
    // ÏÑ∏ÏÖò Ïó∞Ïû• ÏöîÏ≤≠ (Î¶¨ÌîÑÎ†àÏãú ÌÜ†ÌÅ∞ÏúºÎ°ú Í∞±Ïã† ÏãúÎèÑ)
    if (this.isSessionExpired()) {
      console.log('ApiClient: Cannot extend expired session');
      return false;
    }
    
    console.log('ApiClient: Extending session by refreshing token');
    this.refreshAccessToken();
    return true;
  }

  // JWT Í≤ÄÏ¶ù Î©îÏÑúÎìúÎì§
  public isValidJWTFormat(token: string): boolean {
    return validateJWTFormat(token);
  }

  public decodeJWTPayload(token: string): any {
    return decodeJWTPayload(token);
  }

  public isTokenExpired(token: string): boolean {
    return isTokenExpired(token);
  }

  // Í∏∞Ï°¥ debugAuth Î©îÏÑúÎìú Í∞úÏÑ†
  debugAuth(): void {
    console.log('=== Auth Debug Info ===');
    console.log('Current token in memory:', this.token ? `${this.token.substring(0, 10)}...` : 'null');
    
    if (typeof window !== 'undefined') {
      const storedToken = localStorage.getItem('authToken');
      console.log('Stored token in localStorage:', storedToken ? `${storedToken.substring(0, 10)}...` : 'null');
      
      if (storedToken) {
        try {
          console.log('Token valid format:', this.isValidJWTFormat(storedToken));
          console.log('Token expired:', this.isTokenExpired(storedToken));
          
          const payload = this.decodeJWTPayload(storedToken);
          console.log('Token payload:', payload);
          console.log('Token expires at:', new Date(payload.exp * 1000));
          console.log('Current time:', new Date());
        } catch (e) {
          console.log('Token decode error:', e);
        }
      }
    }
    console.log('=======================');
  }

  // Í≤åÏãúÍ∏Ä Í¥ÄÎ†® API
  async getPosts(filters: PostFilters = {}): Promise<ApiResponse<PaginatedResponse<Post>>> {
    console.log('üöÄ getPosts Ìò∏Ï∂ú - filters:', filters);
    
    const queryParams = new URLSearchParams();
    
    if (filters.type) queryParams.append('type', filters.type);
    if (filters.service) queryParams.append('service_type', filters.service);
    if (filters.metadata_type) queryParams.append('metadata_type', filters.metadata_type);
    if (filters.sortBy) queryParams.append('sort_by', filters.sortBy);
    if (filters.search) queryParams.append('search', filters.search);
    if (filters.page) queryParams.append('page', filters.page.toString());
    if (filters.size) queryParams.append('size', filters.size.toString());

    const query = queryParams.toString();
    const endpoint = `/api/posts/${query ? `?${query}` : ''}`;
    
    console.log('üì° API ÏöîÏ≤≠ - endpoint:', endpoint);

    return this.request<PaginatedResponse<Post>>(endpoint);
  }

  async searchPosts(filters: PostFilters = {}): Promise<ApiResponse<PaginatedResponse<Post>>> {
    const queryParams = new URLSearchParams();
    
    // Í≤ÄÏÉâ ÏøºÎ¶¨ (Î∞±ÏóîÎìúÏóêÏÑú 'q' ÌååÎùºÎØ∏ÌÑ∞ Í∏∞ÎåÄ)
    if (filters.query) queryParams.append('q', filters.query);
    
    // Í∏∞ÌÉÄ ÌïÑÌÑ∞ ÌååÎùºÎØ∏ÌÑ∞
    if (filters.service) queryParams.append('service', filters.service);
    if (filters.metadata_type) queryParams.append('metadata_type', filters.metadata_type);
    if (filters.category) queryParams.append('category', filters.category);
    if (filters.sortBy) queryParams.append('sortBy', filters.sortBy);
    if (filters.page) queryParams.append('page', filters.page.toString());
    if (filters.size) queryParams.append('size', filters.size.toString());

    const query = queryParams.toString();
    const endpoint = `/api/posts/search${query ? `?${query}` : ''}`;

    return this.request<PaginatedResponse<Post>>(endpoint);
  }

  async getPost(slug: string): Promise<ApiResponse<Post>> {
    return this.request<Post>(`/api/posts/${slug}`);
  }


  // üöÄ ÏôÑÏ†Ñ ÌÜµÌï© AggregationÏúºÎ°ú Í≤åÏãúÍ∏Ä + ÏûëÏÑ±Ïûê + ÎåìÍ∏Ä + ÎåìÍ∏ÄÏûëÏÑ±Ïûê + ÏÇ¨Ïö©ÏûêÎ∞òÏùëÏùÑ Î™®Îëê Ìïú Î≤àÏóê Ï°∞Ìöå
  async getPostComplete(slug: string): Promise<ApiResponse<any>> {
    return this.request<any>(`/api/posts/${slug}/complete`);
  }

  async createPost(postData: CreatePostRequest): Promise<ApiResponse<Post>> {
    console.log('üöÄ createPost Ìò∏Ï∂ú - Ï†ÑÏÜ°Ìï† Îç∞Ïù¥ÌÑ∞:', JSON.stringify(postData, null, 2));
    return this.request<Post>('/api/posts/', {
      method: 'POST',
      body: JSON.stringify(postData),
    });
  }

  async updatePost(slug: string, postData: Partial<CreatePostRequest>): Promise<ApiResponse<Post>> {
    console.log('üöÄ updatePost Ìò∏Ï∂ú - Ï†ÑÏÜ°Ìï† Îç∞Ïù¥ÌÑ∞:', JSON.stringify(postData, null, 2));
    return this.request<Post>(`/api/posts/${slug}`, {
      method: 'PUT',
      body: JSON.stringify(postData),
    });
  }

  async deletePost(slug: string): Promise<ApiResponse<void>> {
    return this.request<void>(`/api/posts/${slug}`, {
      method: 'DELETE',
    });
  }

  // ÎåìÍ∏Ä Í¥ÄÎ†® API
  async getComments(postSlug: string, page: number = 1): Promise<ApiResponse<CommentListResponse>> {
    return this.request<CommentListResponse>(`/api/posts/${postSlug}/comments?page=${page}`);
  }

  // üöÄ 2Îã®Í≥Ñ: Î∞∞Ïπò Ï°∞ÌöåÎ°ú ÎåìÍ∏ÄÍ≥º ÏûëÏÑ±Ïûê Ï†ïÎ≥¥ Ìï®Íªò Ï°∞Ìöå
  async getCommentsBatch(postSlug: string): Promise<ApiResponse<any>> {
    return this.request<any>(`/api/posts/${postSlug}/comments`);
  }

  async createComment(postSlug: string, commentData: CreateCommentRequest): Promise<ApiResponse<Comment>> {
    return this.request<Comment>(`/api/posts/${postSlug}/comments`, {
      method: 'POST',
      body: JSON.stringify(commentData),
    });
  }

  async updateComment(postSlug: string, commentId: string, content: string): Promise<ApiResponse<Comment>> {
    console.log('API updateComment Ìò∏Ï∂ú:', { postSlug, commentId, content });
    const endpoint = `/api/posts/${postSlug}/comments/${commentId}`;
    console.log('Ìé∏Ïßë ÏöîÏ≤≠ URL:', endpoint);
    
    return this.request<Comment>(endpoint, {
      method: 'PUT',
      body: JSON.stringify({ content }),
    });
  }

  async deleteComment(postSlug: string, commentId: string): Promise<ApiResponse<void>> {
    console.log('API deleteComment Ìò∏Ï∂ú:', { postSlug, commentId });
    const endpoint = `/api/posts/${postSlug}/comments/${commentId}`;
    console.log('ÏÇ≠Ï†ú ÏöîÏ≤≠ URL:', endpoint);
    
    return this.request<void>(endpoint, {
      method: 'DELETE',
    });
  }

  // ÎãµÍ∏Ä ÏûëÏÑ± API
  async createReply(postSlug: string, commentId: string, content: string): Promise<ApiResponse<Comment>> {
    return this.request<Comment>(`/api/posts/${postSlug}/comments/${commentId}/replies`, {
      method: 'POST',
      body: JSON.stringify({ content }),
    });
  }

  // ÎåìÍ∏Ä Ï¢ãÏïÑÏöî/Ïã´Ïñ¥Ïöî API
  async likeComment(postSlug: string, commentId: string): Promise<ApiResponse<any>> {
    console.log('API likeComment Ìò∏Ï∂ú:', { postSlug, commentId });
    const endpoint = `/api/posts/${postSlug}/comments/${commentId}/like`;
    console.log('Ï¢ãÏïÑÏöî ÏöîÏ≤≠ URL:', endpoint);
    
    return this.request<any>(endpoint, {
      method: 'POST',
    });
  }

  async dislikeComment(postSlug: string, commentId: string): Promise<ApiResponse<any>> {
    console.log('API dislikeComment Ìò∏Ï∂ú:', { postSlug, commentId });
    const endpoint = `/api/posts/${postSlug}/comments/${commentId}/dislike`;
    console.log('Ïã´Ïñ¥Ïöî ÏöîÏ≤≠ URL:', endpoint);
    
    return this.request<any>(endpoint, {
      method: 'POST',
    });
  }

  // Î∞òÏùë Í¥ÄÎ†® API (Í≤åÏãúÍ∏ÄÏö© - API v3 Î™ÖÏÑ∏ÏÑú Í∏∞Ï§Ä)
  async toggleReaction(
    targetId: string,
    targetType: 'post' | 'comment',
    reactionType: ReactionType
  ): Promise<ApiResponse<any>> {
    if (targetType === 'post') {
      // Í≤åÏãúÍ∏Ä Î∞òÏùëÏùÄ slug Í∏∞Î∞ò Í∞úÎ≥Ñ ÏóîÎìúÌè¨Ïù∏Ìä∏ ÏÇ¨Ïö©
      return this.request<any>(`/api/posts/${targetId}/${reactionType}`, {
        method: 'POST',
      });
    } else {
      // ÎåìÍ∏Ä Î∞òÏùëÏùÄ ÏùºÎ∞ò reactions ÏóîÎìúÌè¨Ïù∏Ìä∏ ÏÇ¨Ïö© (Íµ¨ÌòÑ ÏòàÏ†ï)
      return this.request<any>(`/api/reactions`, {
        method: 'POST',
        body: JSON.stringify({
          target_id: targetId,
          target_type: targetType,
          reaction_type: reactionType,
        }),
      });
    }
  }

  async getUserReactions(targetId: string, targetType: 'post' | 'comment'): Promise<ApiResponse<Reaction[]>> {
    return this.request<Reaction[]>(`/api/reactions?target_id=${targetId}&target_type=${targetType}`);
  }

  // Í≤åÏãúÍ∏Ä Î∞òÏùë Í∞úÎ≥Ñ Î©îÏÑúÎìúÎì§ (Îçî Î™ÖÌôïÌïú API)
  async likePost(slug: string): Promise<ApiResponse<any>> {
    return this.request<any>(`/api/posts/${slug}/like`, {
      method: 'POST',
    });
  }

  async dislikePost(slug: string): Promise<ApiResponse<any>> {
    return this.request<any>(`/api/posts/${slug}/dislike`, {
      method: 'POST',
    });
  }

  async bookmarkPost(slug: string): Promise<ApiResponse<any>> {
    return this.request<any>(`/api/posts/${slug}/bookmark`, {
      method: 'POST',
    });
  }

  // üÜï ÏÑúÎπÑÏä§ Í≤åÏãúÍ∏Ä ÌôïÏû• ÌÜµÍ≥Ñ Ï°∞Ìöå
  async getServicePostWithExtendedStats(slug: string): Promise<ApiResponse<any>> {
    return this.request<any>(`/api/posts/services/${slug}`);
  }

  // üÜï ÏÑúÎπÑÏä§ Í≤åÏãúÍ∏Ä Î™©Î°ù ÌôïÏû• ÌÜµÍ≥Ñ Ï°∞Ìöå
  async getServicePostsWithExtendedStats(
    page: number = 1, 
    size: number = 20, 
    sortBy: string = "created_at"
  ): Promise<ApiResponse<any>> {
    const params = new URLSearchParams({
      page: page.toString(),
      size: size.toString(),
      sort_by: sortBy
    });
    return this.request<any>(`/api/posts/services?${params.toString()}`);
  }

  // üÜï ÏÑúÎπÑÏä§ Î¨∏Ïùò/ÌõÑÍ∏∞ API
  async createServiceInquiry(postSlug: string, inquiryData: CreateCommentRequest): Promise<ApiResponse<Comment>> {
    return this.request<Comment>(`/api/posts/${postSlug}/comments/inquiry`, {
      method: 'POST',
      body: JSON.stringify(inquiryData),
    });
  }

  async createServiceReview(postSlug: string, reviewData: CreateCommentRequest): Promise<ApiResponse<Comment>> {
    return this.request<Comment>(`/api/posts/${postSlug}/comments/review`, {
      method: 'POST',
      body: JSON.stringify(reviewData),
    });
  }

  // Ïù¥Î©îÏùº Ïù∏Ï¶ù API
  async sendVerificationEmail(request: EmailVerificationRequest): Promise<ApiResponse<EmailVerificationResponse>> {
    return this.request<EmailVerificationResponse>('/api/auth/send-verification-email', {
      method: 'POST',
      body: JSON.stringify(request),
    });
  }

  async verifyEmailCode(request: EmailVerificationCodeRequest): Promise<ApiResponse<EmailVerificationCodeResponse>> {
    return this.request<EmailVerificationCodeResponse>('/api/auth/verify-email-code', {
      method: 'POST',
      body: JSON.stringify(request),
    });
  }

  // API ÌÖåÏä§Ìä∏Ïö© Î©îÏÑúÎìú
  async testApiCall(request: ApiTestRequest): Promise<ApiTestResponse> {
    const startTime = Date.now();
    
    try {
      let url = `${this.baseURL}${request.endpoint}`;
      
      // Query parameters Ï≤òÎ¶¨
      if (request.queryParams) {
        const queryParams = new URLSearchParams(request.queryParams);
        url += `?${queryParams.toString()}`;
      }

      const response = await fetch(url, {
        method: request.method,
        headers: {
          'Content-Type': 'application/json',
          ...request.headers,
        },
        body: request.body ? JSON.stringify(request.body) : undefined,
      });

      const data = await response.json();
      const duration = Date.now() - startTime;

      return {
        status: response.status,
        data,
        headers: Object.fromEntries(response.headers.entries()),
        duration,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      const duration = Date.now() - startTime;
      
      return {
        status: 0,
        data: {
          error: error instanceof Error ? error.message : 'Unknown error',
        },
        headers: {},
        duration,
        timestamp: new Date().toISOString(),
      };
    }
  }
}

export const apiClient = new ApiClient();
export default apiClient;